<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Axios拦截请求封装</title>
    <url>/2022/02/22/axios/index/</url>
    <content><![CDATA[<h2 id="Axios拦截请求封装"><a href="#Axios拦截请求封装" class="headerlink" title="Axios拦截请求封装"></a>Axios拦截请求封装</h2><p>请求封装</p>
<pre><code class="js">import { ApiError } from &#39;@/structure/Request&#39;;
import { Config } from &#39;@/utils/Config&#39;;
import axios, { AxiosRequestConfig } from &#39;axios&#39;;

const service = axios.create({
  baseURL: Config.API_ADDRESS,
  timeout: Config.TIME_OUT
});

// 请求拦截器
service.interceptors.request.use(
  (config: AxiosRequestConfig) =&gt; {
    config.headers[&#39;token&#39;] = Config.getToken() || &#39;&#39;;
    return config;
  },
  error =&gt; {
    Promise.reject(error);
  }
);

// 响应拦截器
service.interceptors.response.use(
  response =&gt; {
    const data = response.data;
    if (data.code !== 200) {
      switch (data.code) {
        case 400:
          return Promise.reject(ApiError.BadRequest);
        case 401:
          return Promise.reject(ApiError.Unauthorized);
        case 403:
          return Promise.reject(ApiError.Forbidden);
        case 404:
          return Promise.reject(ApiError.ResourceNotFound);
        case 500:
          return Promise.reject(ApiError.ServerSideError);
        case 1001:
          return Promise.reject(ApiError.CustomError.from(data.msg));
        default:
          return Promise.reject(ApiError.Unexpected.from(data.msg));
      }
    } else {
      return data;
    }
  },
  error =&gt; {
    return Promise.reject(error);
  }
);

export default service;

</code></pre>
<p>调用封装</p>
<pre><code class="js">import { ApiResponse } from &#39;@/structure/Request&#39;;
import service from &#39;@/utils/service&#39;;

export class CommonApi {
  public static async getTimestamp(): Promise&lt;number&gt; {
    const response = await service.get&lt;void, ApiResponse&lt;number&gt;&gt;(&#39;/utils/getSystemTime&#39;);
    return response.result;
  }
}
</code></pre>
]]></content>
      <categories>
        <category>Axios</category>
      </categories>
      <tags>
        <tag>Axios</tag>
        <tag>Axios拦截</tag>
      </tags>
  </entry>
  <entry>
    <title>数组遍历的实现</title>
    <url>/2022/02/23/array-traverse-rewrite/index/</url>
    <content><![CDATA[<h2 id="实现数组的filter方法"><a href="#实现数组的filter方法" class="headerlink" title="实现数组的filter方法"></a>实现数组的filter方法</h2><pre><code class="js">Array.prototype.filter =&gt; (fn) {
  let arr = [];
  for (let i = 0; i &lt; this.lenght; i++) {
    if (fn(this[i], i, this)) {
      arr.push(this[i])
    }
  }
  return arr;
}
</code></pre>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Array</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>手写form组件</title>
    <url>/2022/02/25/form-component/index/</url>
    <content><![CDATA[<h2 id="form组件"><a href="#form组件" class="headerlink" title="form组件"></a>form组件</h2><p>input组件</p>
<pre><code class="vue">&lt;template&gt;
  &lt;div&gt;
    &lt;input :value=&quot;value&quot; @input=&quot;onInput&quot; v-bind=&quot;$attrs&quot;&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  inheritAttrs: false,
  props: {
    value: {
      type: String,
      default: &#39;&#39;
    }
  },
  methods: {
    onInput(e) {
      this.$emit(&#39;input&#39;, e.target.value);
      // 防止input多层嵌套，formItem无法正常派发事件
      const parent = this.getParent(this.$parent);
      parent.$emit(&#39;validate&#39;);
    },
    getParent(parent) {
      if (parent.$options._componentTag === &#39;CFormItem&#39;) return parent;
      this.getParent(parent.$parent);
    }
  }
}
&lt;/script&gt;
</code></pre>
<p>checkbox组件</p>
<pre><code class="vue">&lt;template&gt;
  &lt;div&gt;
    &lt;input type=&quot;checkbox&quot; :checked=&quot;checked&quot; @change=&quot;onCahnge&quot; v-bind=&quot;$attrs&quot;&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  inheritAttrs: false,
  props: {
    checked: {
      type: Boolean,
      default: false
    }
  },
  model: {
    prop: &#39;checked&#39;,
    event: &#39;change&#39;
  },
  methods: {
    onCahnge(e) {
      this.$emit(&#39;change&#39;, e.target.checked);
      const parent = this.getParent(this.$parent);
      parent.$emit(&#39;validate&#39;);
    },
    getParent(parent) {
      if (parent.$options._componentTag === &#39;CFormItem&#39;) return parent;
      this.getParent(parent.$parent);
    }
  }
}
&lt;/script&gt;
</code></pre>
<p>formItem组件</p>
<pre><code class="vue">&lt;template&gt;
  &lt;div&gt;
    &lt;label v-if=&quot;label&quot;&gt;
      {{ label }}
    &lt;/label&gt;
    &lt;slot&gt;&lt;/slot&gt;
    &lt;p v-if=&quot;erroeMsg&quot;&gt;{{ erroeMsg }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
/*
  表单异步验证js库：async-validator，element-ui中的form组件所使用的验证方式。
  npm install --save async-validator
*/
import Schema from &#39;async-validator&#39;;
export default {
  props: {
    label: {
      type: String,
      default: &#39;&#39;
    },
    prop: {
      type: String
    }
  },
  inject: [&#39;form&#39;],
  data() {
    return {
      erroeMsg: &#39;&#39;
    }
  },
  mounted() {
    this.$on(&#39;validate&#39;, () =&gt; {
      this.validate();
    })
  },
  methods: {
    validate() {
      // 获取校验规则
      const rule = this.form.rules[this.prop];
      // 获取数值
      const value = this.form.model[this.prop];
      // 执行校验
      const desc = {
        [this.prop]: rule
      };
      const schema = new Schema(desc);
      return schema.validate({[this.prop]: value}, errors =&gt; {
        if (errors) {
          this.erroeMsg = errors[0].message;
        } else {
          this.erroeMsg = &#39;&#39;;
        }
      });
    }
  }
}
&lt;/script&gt;
</code></pre>
<p>form组件</p>
<pre><code class="vue">&lt;template&gt;
  &lt;div&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  props: {
    model: {
      type: Object,
      requireg: true
    },
    rules: {
      type: Object
    }
  },
  provide() {
    return {
      form : this
    }
  },
  data() {
    return {
    }
  },
  methods: {
    validate(cb) {
      const tasks = this.$children
        .filter(item =&gt; item.prop)
        .map(item =&gt; item.validate());
      Promise.all(tasks)
        .then(() =&gt; cb(true))
        .catch(() =&gt; cb(false))
    }
  }
}
&lt;/script&gt;
</code></pre>
<p>引用form组件</p>
<pre><code class="vue">&lt;template&gt;
  &lt;div class=&quot;wrap&quot;&gt;
    &lt;CForm :model=&quot;model&quot; :rules=&quot;rules&quot; ref=&quot;form&quot;&gt;
      &lt;CFormItem label=&quot;用户名&quot; prop=&quot;userName&quot;&gt;
        &lt;CInput v-model=&quot;model.userName&quot;&gt;&lt;/CInput&gt;
      &lt;/CFormItem&gt;
      &lt;CFormItem label=&quot;密码&quot; prop=&quot;passWord&quot;&gt;
        &lt;CInput v-model=&quot;model.passWord&quot; type=&quot;passWord&quot;&gt;&lt;/CInput&gt;
      &lt;/CFormItem&gt;
      &lt;CFormItem label=&quot;勾选&quot; prop=&quot;checked&quot;&gt;
        &lt;CCheckBox v-model=&quot;model.checked&quot;&gt;&lt;/CCheckBox&gt;
      &lt;/CFormItem&gt;
      &lt;CFormItem&gt;
        &lt;button @click=&quot;login&quot;&gt;登录&lt;/button&gt;
      &lt;/CFormItem&gt;

      {{ model }}
    &lt;/CForm&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import CForm from &#39;@/components/form/index&#39;;
import CInput from &#39;@/components/form/input.vue&#39;
import CCheckBox from &#39;@/components/form/checkBox&#39;
import CFormItem from &#39;@/components/form/formItem.vue&#39;
export default {
  components: {
    CForm,
    CInput,
    CFormItem,
    CCheckBox
  },
  data() {
    return {
      model: {
        userName: &#39;&#39;,
        passWord: &#39;&#39;,
        checked: false
      },
      rules: {
        userName: [{required: true, message: &quot;请输入用户名&quot;}],
        passWord: [{required: true, message: &quot;请输入密码&quot;}],
        checked: [{validator: (rule, value) =&gt; value, message: &quot;请勾选&quot;}]
      }
    }
  },
  methods: {
    login() {
      this.$refs.form.validate((isValid) =&gt; {
        if (isValid) {
          alert(&#39;登录！&#39;)
        } else {
          alert(&#39;错误！&#39;)
        }
      })
    }
  },
  created() {
    // console.log(&#39;路由查询参数&#39;,this.$tab.query())
  },
}
&lt;/script&gt;
&lt;style scoped&gt;
&lt;/style&gt;
</code></pre>
]]></content>
      <categories>
        <category>form</category>
      </categories>
      <tags>
        <tag>form</tag>
        <tag>组件</tag>
        <tag>表单验证</tag>
      </tags>
  </entry>
  <entry>
    <title>前端 JS 编程题（应用类）</title>
    <url>/2021/11/16/js-application/index/</url>
    <content><![CDATA[<h3 id="一、手写防抖（debounce）"><a href="#一、手写防抖（debounce）" class="headerlink" title="一、手写防抖（debounce）"></a>一、手写防抖（debounce）</h3><pre><code class="js">// debounce
// 举例：购物车加减数量
function debounce(fn, delay=500) {
    // timer 写在闭包中，因此防抖也是闭包的一个应用
    let timer = null;

    return function() {
        if (timer) {
            clearTimeout(timer)
        }
        timer = setTimeout(() =&gt; {
            fn.apply(this, arguments);
            timer = null;
        }, delay)
    }
}

// 验证
input1.addEventListener(&#39;keyup&#39;, debounce(() =&gt; {
  console.log(input1.value);
}), 600)
</code></pre>
<h3 id="二、手写节流（throttle）"><a href="#二、手写节流（throttle）" class="headerlink" title="二、手写节流（throttle）"></a>二、手写节流（throttle）</h3><pre><code class="js">// 节流
// 举例：button按钮点击后置灰
function throttle(fn, delay=100) {
  let timer = null;

  return () =&gt; {
    if (timer) return;
    timer = setTimeOut(() =&gt; {
      fn.apply(this, arguments);
      timer = null;
    }, delay)
  }
}

// 验证
div1.addEventListener((&#39;drag&#39;, throttle(function (e) {
    console.log(e.offsetX, e.offsetY)
})))
</code></pre>
<h3 id="三、事件委托"><a href="#三、事件委托" class="headerlink" title="三、事件委托"></a>三、事件委托</h3><p>假设一个 ul 下有一万个 li，li 的 innerHTML 是从 0 到 9999，当点击某个 li 时输出该 li 代表的值</p>
<pre><code class="js">window.onload = function() {
  // 创建dom
  var ul = document.getElementsByTagName(&quot;ul&quot;);
  var arr = [];
  for (let i = 0; i &lt; 100000; i++) {
      arr.push(i);
  }
  ul[0].innerHTML = &#39;&lt;li&gt;&#39; + arr.join(&#39;&lt;/li&gt;&lt;li&gt;&#39;) + &#39;&lt;/li&gt;&#39;

  // 事件委托 
  let ul = document.getElementById(&#39;ul&#39;);
  ul.onclick = (e) =&gt; {
    console.log(e.target.innerText)
  }
}
</code></pre>
<h2 id="四、手写-Promise-加载一张图片"><a href="#四、手写-Promise-加载一张图片" class="headerlink" title="四、手写 Promise 加载一张图片"></a>四、手写 Promise 加载一张图片</h2><pre><code class="js">function loadImg(scr) {
  return new Promise((resolve, reject) =&gt; {
    const img = document.createElement(&#39;img&#39;);
    img.onload = () =&gt; {
      resolve(img);
    }
    img.onerror = () =&gt; {
      reject(new Error(`图片加载失败 ${src}`))
    }
    img.src = src;
  })
}

const url = &#39;https://pic.leetcode-cn.com/1604237471-xbJgZl-%E5%9B%BE%E7%89%871.png&#39;;
loadImg(url).then(img =&gt; {
    console.log(img.width)
    return img
}).then(img =&gt; {
    console.log(img.height)
}).catch(ex =&gt; console.error(ex))
</code></pre>
<h2 id="五、用-ajaxajax-原生实现一个-post-请求"><a href="#五、用-ajaxajax-原生实现一个-post-请求" class="headerlink" title="五、用 ajaxajax 原生实现一个 post 请求"></a>五、用 ajaxajax 原生实现一个 post 请求</h2><pre><code class="js">function ajax_post(url, data) {
    // 1. 异步对象 ajax
    var ajax = new XMLHttpRequest();

    // 2. url 方法
    ajax.open(&#39;post&#39;, url);

    // 3. 设置请求报文
    ajax.setRequestHeader(&#39;Content-type&#39;, &#39;text/plain&#39;);

    // 4. 发送
    if (data) {
        ajax.send(data);
    } else {
        ajax.send();
    }

    // 5. 注册事件
    ajax.onreadystatechange = function () {
        if (ajax.readyState === 4 &amp;&amp; ajax.status === 200) {
            console.log(ajax.respenseText);
        }
    }
}
</code></pre>
<h2 id="六、每隔一秒输出一个数字"><a href="#六、每隔一秒输出一个数字" class="headerlink" title="六、每隔一秒输出一个数字"></a>六、每隔一秒输出一个数字</h2><pre><code class="js">// 使用let
for (let i = 0; i &lt; 10; i++) {
    setTimeout(() =&gt; {
        console.log(i);
    }, 1000 * i)
}

// 使用闭包
for (var i = 0; i &lt; 10; i++) {
    (function(j) {
        setTimeout(() =&gt; {
            console.log(j);
        }, 1000 * j)
    })(i)
}

// 使用settimeout第三个参数
for(var i = 0; i &lt;= 5; i++){           
    setTimeout((j) =&gt; {                
        console.log(j);            
    },i * 1000, i)        
}
</code></pre>
<h2 id="七、-判断两个对象是否相等"><a href="#七、-判断两个对象是否相等" class="headerlink" title="七、 判断两个对象是否相等"></a>七、 判断两个对象是否相等</h2><pre><code class="js">/*
 * @param x {Object} 对象1
 * @param y {Object} 对象2
 * @return  {Boolean} true 为相等，false 为不等
 */

 const deepEqual = (x, y) =&gt; {
  if (x === y) {
    return true;
  } else if ((typeof x === &#39;object&#39; &amp;&amp; x != null) &amp;&amp; (typeof y === &#39;object&#39; &amp;&amp; y != null)) {
    if (Object.keys(x).length !=== Object.keys(y).length) return false;
    for (let prop in x) {
      if (y.hasOwnproperty(prop)) {
        if (!deepEqual(x.prop, y.prop)) return false;
      } else {
        return false;
      }
    }
    return true;
  }
  return false;
 }

//  调库实现
console.log(_.isEqual(x, y))
</code></pre>
]]></content>
      <categories>
        <category>笔记</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端</tag>
        <tag>应用</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Git与Github进行SSH连接</title>
    <url>/2020/04/14/git-github-ssh/index/</url>
    <content><![CDATA[<h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>1、到Git官网下载与你正在使用的操作系统(本文以windows为例)相对应的文件。一般地，选择64-bit Git for Windows Setup<br>2、安装时注意：勾选添加git到环境变量；在Windows Explorer Integration中勾选Git Bash Here。其余配置默认即可<br>3、安装完成后(可能需要注销或重启)，在任意一个文件夹空白处右键，检查是否有Git Bash Here的选项</p>
<h3 id="设置邮箱和用户名"><a href="#设置邮箱和用户名" class="headerlink" title="设置邮箱和用户名"></a>设置邮箱和用户名</h3><p>打开Git Bash，输入命令均在Git Bash中进行</p>
<pre><code class="js">git config --global user.name &quot;WangRongsheng&quot;
git config --global user.email &quot;603329354@qq.com&quot;
</code></pre>
<h3 id="设置邮箱和用户名-1"><a href="#设置邮箱和用户名-1" class="headerlink" title="设置邮箱和用户名"></a>设置邮箱和用户名</h3><pre><code class="js">ssh-keygen -t rsa -C &quot;603329354@qq.com&quot;
</code></pre>
<p>回车之后会出现如下所示的输出，直接按回车即可：</p>
<pre><code class="js">Generating public/private rsa key pair.
Enter file in which to save the key
(/Users/your_user_directory/.ssh/id_rsa): (按回车键)
Enter passphrase (empty for no passphrase): (按回车键)
Enter same passphrase again: (按回车键)
</code></pre>
<h3 id="将公钥添加到github中"><a href="#将公钥添加到github中" class="headerlink" title="将公钥添加到github中"></a>将公钥添加到github中</h3><p>1、在C:\user\xxx.ssh\文件夹中找到id_rsa.pub这个文件，用文本编辑器(如记事本)打开，复制里面的所有内容<br>2、登陆github账号，点击头像旁的小三角展开，点击settings-SSH and GPG keys-New SSH key，在Title中取一个名字（任意），key中粘贴你刚刚复制的内容。然后点击Add SSH key即可</p>
<h3 id="测试是否关联成功"><a href="#测试是否关联成功" class="headerlink" title="测试是否关联成功"></a>测试是否关联成功</h3><p>输入：</p>
<pre><code class="js">ssh -T git@github.com
</code></pre>
<p>出现以下结果即为成功：</p>
<pre><code class="js">Hi WangRongsheng! You&#39;ve successfully authenticated, but GitHub does not provide shell access.
</code></pre>
]]></content>
      <categories>
        <category>git</category>
        <category>github</category>
        <category>ssh</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>前端 JS 编程题（算法类）</title>
    <url>/2021/11/14/js-algorithm/index/</url>
    <content><![CDATA[<h3 id="一、手写快排、冒泡、选择排序"><a href="#一、手写快排、冒泡、选择排序" class="headerlink" title="一、手写快排、冒泡、选择排序"></a>一、手写快排、冒泡、选择排序</h3><h4 id="①-快速排序"><a href="#①-快速排序" class="headerlink" title="① 快速排序"></a>① 快速排序</h4><pre><code class="js">/**
 * --- 测试用例 ---
 *
 * 输入：[1, 34, 5, 76, 8, 6, 9, 7, 6, 3]
 * 输出：[1, 3, 5, 6, 6, 7, 8, 9, 34, 76]
 *
 * --- 说明 ---
 * 
 * 思考：快速排序是稳定的吗？
 * 解答：base 的每次选择，会导致快排是不稳定排序。
 */

const quickSort = (nums) =&gt; {
    if (nums.length &lt; 2) {
        return nums;
    } else {
        var left = [];
        var right = [];
        var pivot = Math.floor(nums.length / 2); // Math.floor 向下取整
        var base = nums.splice(pivot, 1)[0];
        for (let i = 0; i &lt; nums.length; i++) {
            if (nums[i] &lt; base) {
                left.push(nums[i]);
            } else {
                right.push(nums[i]);
            }
        }
    }
    return quickSort(left).concat([base], quickSort(right));
}
</code></pre>
<h4 id="②-冒泡排序"><a href="#②-冒泡排序" class="headerlink" title="② 冒泡排序"></a>② 冒泡排序</h4><pre><code class="js">/**
 * --- 测试用例 ---
 *
 * 输入：[5, 2, 4, 7, 9, 8, 3, 6, 3, 8, 3]
 * 输出：[2, 3, 3, 3, 4, 5, 6, 7, 8, 8, 9]
 *
 * --- 说明 ---
 * 
 * 思考：冒泡排序是稳定的吗？
 * 解答：稳定。相等的元素不发生交换
 */

const bubbleSort = (nums) =&gt; {
    for (var i = 0; i &lt; nums.length - 1; i++) {
        for (var j = 0; j &lt; nums.length - 1 - i; j++) {
            if (nums[j] &gt; nums[j + 1]) {
                let tmp = nums[j];
                nums[j] = nums[j + 1];
                nums[j + 1] = tmp;
            }
        }
    }
    return nums;
}
</code></pre>
<h4 id="③-选择排序"><a href="#③-选择排序" class="headerlink" title="③ 选择排序"></a>③ 选择排序</h4><pre><code class="js">/**
 * --- 测试用例 ---
 *
 * 输入：[6, 45, 3, 2, 5, 6, 8, 4, 3, 4, 56, 67, 5]
 * 输出：[2, 3, 3, 4, 4, 5, 5, 6, 6, 8, 45, 56, 67]
 *
 * --- 说明 ---
 * 
 * 思考：选择排序是稳定的吗？
 * 解答：要看代码是如何实现的，在本例中由于有交换，所以是不稳定排序。
 */

const selectSort = (nums) =&gt; {
    var idx; // 最小值的索引
    for (var i = 0; i &lt; nums.length - 1; i++) {
        idx = i;
        for (var j = i + 1; j &lt; nums.length; j++) {
            if (nums[j] &lt; nums[idx]) {
                idx = j;
            }
        }
        if (nums[i] &gt; nums[idx]) {
            let tmp = nums[idx];
            nums[idx] = nums[i];
            nums[i] = tmp;
        }
    }
    return nums;
}s
</code></pre>
<h2 id="二、URL-拆解问题"><a href="#二、URL-拆解问题" class="headerlink" title="二、URL 拆解问题"></a>二、URL 拆解问题</h2><h3 id="①"><a href="#①" class="headerlink" title="①"></a>①</h3><pre><code class="js">/**
 * --- 题目描述 ---
 * 
 * 实现一个函数，可以对 url 中的 query 部分做拆解，返回一个 key: value 形式的 object  
 * 
 * --- 实例 ---
 * 
 * 输入：&#39;http://sample.com/?a=1&amp;e&amp;b=2&amp;c=xx&amp;d#hash&#39; 
 * 输出：{a: 1, b: 2, c: &#39;xx&#39;, d: &#39;&#39;}  
 */

function getQueryObj(url) {
    // TODO
    let arr = url.split(&#39;?&#39;)[1].split(&#39;#&#39;)[0].split(&#39;&amp;&#39;);
    const res = {};
    arr.forEach(e =&gt; {
        const [key, value] = e.split(&#39;=&#39;);
        if (!value) {
            res[key] = &#39;&#39;;
        } else {
            res[key] = value;
        }
    })
    return res;
}
</code></pre>
<h3 id="②"><a href="#②" class="headerlink" title="②"></a>②</h3><pre><code class="js">/**
 * --- 题目描述 ---
 *
 * 实现一个 parseParem 函数，将 url 转化为指定结果
 *
 * --- 测试用例 ---
 *
 * 输入：url = &#39;http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled&#39;
 * 输出：
{
 user:&#39;anonymous&#39;,
 id:[123,456],// 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型
 city:&#39;北京&#39;,// 中文需解码
 enabled: true // 未指定值的 key 与约定为 true
}
 */

const parseParem = (url) =&gt; {
    const arr = url.split(&#39;?&#39;)[1].split(&#39;&amp;&#39;);
    const res = {};
    arr.forEach((e) =&gt; {
        let key = e.split(&#39;=&#39;)[0], value = e.split(&#39;=&#39;)[1];
        if (value === undefined) {
            res[key] = true;
        } else {
            if (key in res) {
                Array.isArray(res[key]) ? res[key].push(value) : res[key] = [res[key]].concat(value);
            } else {
                res[key] = decodeURI(value)
            }
        }
    })
    return res;
}
</code></pre>
<h2 id="三、将-HTTP-header-转换成-js-对象"><a href="#三、将-HTTP-header-转换成-js-对象" class="headerlink" title="三、将 HTTP header 转换成 js 对象"></a>三、将 HTTP header 转换成 js 对象</h2><pre><code class="JS">/**
 * --- 题目描述 ---
 *
 * 实现一个方法，把 HTTP 文本形式(字符串)的 header 转换成 JS 对象。
 * 
 * --- 测试用例 ---
 * 
 * 输入：
 * `Accept-Ranges: bytes 
 * Cache-Control: max-age=6000, public
 * Connection: keep-alive
 * Content-Type: application/javascript`
 * 输出：
 * {
 *   &quot;Accept-Ranges&quot;: &quot;bytes&quot;,
 *   &quot;Cache-Control&quot;: &quot;max-age=6000, public&quot;,
 *   Connection: &quot;keep-alive&quot;,
 *   &quot;Content-Type&quot;: &quot;application/javascript&quot;
 * }
 *
 * --- 解题思路 ---
 *
 * 1. 首先将每行数据作为数组的一个元素
 * 2. 将每个元素使用冒号分割，前面为 `key`，后面为 `value`。
 */

const solution = (s) =&gt; {
    let res = {};
    let arr = s.split(&quot;\n&quot;);
    arr.forEach((e) =&gt; {
        let tmp = e.split(&quot;: &quot;);
        res[tmp[0]] = tmp[1];
    })
    return res;
}
</code></pre>
<h2 id="四、数组扁平化"><a href="#四、数组扁平化" class="headerlink" title="四、数组扁平化"></a>四、数组扁平化</h2><h3 id="①-递归"><a href="#①-递归" class="headerlink" title="① 递归"></a>① 递归</h3><pre><code class="JS">var arr = [1, [2, [3, 4]]];

function flatten(arr) {
    var result = [];
    for (var i = 0, len = arr.length; i &lt; len; i++) {
        if (Array.isArray(arr[i])) {
            result = result.concat(flatten(arr[i]))
        }
        else {
            result.push(arr[i])
        }
    }
    return result;
}

console.log(flatten(arr))
</code></pre>
<h3 id="②-es6-拓展运算符"><a href="#②-es6-拓展运算符" class="headerlink" title="② es6 拓展运算符"></a>② es6 拓展运算符</h3><pre><code class="JS">var arr = [1, [2, [3, 4]]];

function flatten(arr) {

    while (arr.some(item =&gt; Array.isArray(item))) {
        arr = [].concat(...arr);
    }
    return arr;
}

console.log(flatten(arr))
</code></pre>
<h3 id="③-flat"><a href="#③-flat" class="headerlink" title="③ flat"></a>③ flat</h3><pre><code class="JS">const arr1 = [0, 1, 2, [[[3, 4]]]];

console.log(arr1.flat(3)); // 3 代表数组内最多嵌套层数
// output: [0, 1, 2, 3, 4]
</code></pre>
]]></content>
      <categories>
        <category>笔记</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端</tag>
        <tag>面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>electron（send、sendSync、invoke）主进程与渲染进程通信的区别</title>
    <url>/2022/04/06/electron-ipc/index/</url>
    <content><![CDATA[<h2 id="ipcRender-send"><a href="#ipcRender-send" class="headerlink" title="ipcRender.send"></a>ipcRender.send</h2><p>渲染进程 render.js</p>
<pre><code class="js">// render.js
const { ipcRenderer } = require(&#39;electron&#39;);

// send 方法发送，并绑定另一个事件接收返回值
function sendMessageToMain() {
  ipcRenderer.send(&#39;render-send-to-main&#39;, &#39;我是渲染进程通过 send 发送的消息&#39;);
}
ipcRenderer.on(&#39;main-reply-to-render&#39;, (event, message) =&gt; {
  console.log(&#39;replyMessage&#39;, message); // &#39;replyMessage 主进程通过 reply 回复给渲染进程的消息&#39;
})
</code></pre>
<p>主进程 main.js：</p>
<pre><code class="js">// main.js
const { ipcMain } = require(&#39;electron&#39;);

ipcMain.on(&#39;render-send-to-main&#39;, (event, message) =&gt; {
  console.log(`receive message from render: ${message}`)
  event.reply(&#39;main-reply-to-render&#39;, &#39;主进程通过 reply 回复给渲染进程的消息&#39;)
})
</code></pre>
<p>1、主进程通过 ipcMain.on 来监听渲染进程的消息<br>2、主进程接收到消息后，可以回复消息，也可以不回复。如果回复的话，通过 event.reply 发送另一个事件，渲染进程监听这个事件得到回复结果。如果不回复消息的话，渲染进程将接着执行 ipcRenderer.send 之后的代码</p>
<h2 id="ipcRender-sendSync"><a href="#ipcRender-sendSync" class="headerlink" title="ipcRender.sendSync"></a>ipcRender.sendSync</h2><p>渲染进程 render.js：</p>
<pre><code class="js">// render.js
const { ipcRenderer } = require(&#39;electron&#39;);

function sendSyncMessageToMain() {
  const replyMessage = ipcRenderer.sendSync(&#39;render-send-sync-to-main&#39;, &#39;我是渲染进程通过 syncSend 发送给主进程的消息&#39;);
  console.log(&#39;replyMessage&#39;, replyMessage); // &#39;主进程回复的消息&#39;
}
</code></pre>
<p>主进程 main.js：</p>
<pre><code class="js">// main.js
const { ipcMain } = require(&#39;electron&#39;);

ipcMain.on(&#39;render-send-sync-to-main&#39;, (event, message) =&gt; {
  console.log(`receive message from render: ${message}`)
  event.returnValue = &#39;主进程回复的消息&#39;;
})
</code></pre>
<p>1、主进程通过 ipcMain.on 来处理渲染进程发送的消息<br>2、主进程通过 event.returnValue 回复渲染进程消息<br>3、如果 event.returnValue 不为 undefined 的话，渲染进程会等待 sendSync 的返回值才执行后面的代码<br>4、请保证 event.returnValue是有值的，否则会造成非预期的影响</p>
<h2 id="ipcRender-invoke"><a href="#ipcRender-invoke" class="headerlink" title="ipcRender.invoke"></a>ipcRender.invoke</h2><p>渲染进程 render.js：</p>
<pre><code class="js">// render.js
const { ipcRenderer } = require(&#39;electron&#39;);

async function invokeMessageToMain() {
  const replyMessage = await ipcRenderer.invoke(&#39;render-invoke-to-main&#39;, &#39;我是渲染进程通过 invoke 发送的消息&#39;);
  console.log(&#39;replyMessage&#39;, replyMessage);
}
</code></pre>
<p>主进程 main.js：</p>
<pre><code class="js">// main.js
const { ipcMain } = require(&#39;electron&#39;);

ipcMain.handle(&#39;render-invoke-to-main&#39;, async (event, message) =&gt; {
  console.log(`receive message from render: ${message}`)
  const result = await asyncWork();
  return result;
})

const asyncWork = async () =&gt; {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve(&#39;延迟 2 秒获取到主进程的返回结果&#39;)
    }, 2000)
  })
}
</code></pre>
<p>1、主进程通过 ipcMain.handle 来处理渲染进程发送的消息<br>2、主进程接收到消息后，可以回复消息，也可以不回复。如果回复消息的话，可以通过 return 给渲染进程回复消息；如果不回复消息的话，渲染进程将接着执行 ipcRenderer.invoke 之后的代码<br>3、渲染进程异步等待主进程的回应， invoke 的返回值是一个 Promise</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>electron</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>前端 JS 编程题（原理类）</title>
    <url>/2021/11/14/js-principle/index/</url>
    <content><![CDATA[<h3 id="一、-深拷贝"><a href="#一、-深拷贝" class="headerlink" title="一、 深拷贝"></a>一、 深拷贝</h3><pre><code class="js">// deepClone
function deepClone(obj = {}) {
    if (typeof obj !== &#39;object&#39; || obj == null) {
        // obj 是 null 或者不是对象和数组，直接返回
        return obj;
    }
    let res;
    if (obj instanceof Array) {
        res = [];
    } else {
        res = {};
    }

    for (let key in obj) {
        // 判断自身中是否包含自身属性
        if (obj.hasOwnProperty(key)) {
            res[key] = deepClone(obj[key])
        }
    }
    return res;
}
// 验证
o = {a: 1, d: {c: &#39;4&#39;}};
res = deepClone(o);
console.log(res);
console.log(res == o);
</code></pre>
<h3 id="二、浅拷贝"><a href="#二、浅拷贝" class="headerlink" title="二、浅拷贝"></a>二、浅拷贝</h3><pre><code class="js">// 首先定义一个对象
const hero = {
  name: &#39;Batman&#39;,
  city: &#39;Gotham&#39;
};
// **********************方法一**********************
const heroEnhancedClone = {
  ...hero,
  name: &#39;Batman Clone&#39;,
  realName: &#39;Bruce Wayne&#39;
};

// 验证
// { name: &#39;Batman Clone&#39;, city: &#39;Gotham&#39;, realName: &#39;Bruce Wayne&#39; }
heroEnhancedClone;

// **********************方法二**********************
const { ...heroClone } = hero;

// 验证
heroClone; // { name: &#39;Batman&#39;, city: &#39;Gotham&#39; }
hero === heroClone; // =&gt; false

// **********************方法三**********************
const hero = {
  name: &#39;Batman&#39;,
  city: &#39;Gotham&#39;
};

// 验证
const heroClone = Object.assign({}, hero);
heroClone; // { name: &#39;Batman&#39;, city: &#39;Gotham&#39; }
hero === heroClone; // =&gt; false
</code></pre>
<h3 id="三、手写-bind-函数"><a href="#三、手写-bind-函数" class="headerlink" title="三、手写 bind 函数"></a>三、手写 bind 函数</h3><pre><code class="js">// 模拟 bind
Function.prototype.bind1 = function() {
    // 将参数拆解为数组
    const args = Array.prototype.slice.call(arguments) // 变成数组

    // 获取 this（数组第一项）
    const t = args.shift()

    // fn1.bind(...) 中的 fn1
    const self = this

    // 返回一个函数
    return function() {
        return self.apply(t, args)
    }
}
function fn1(a, b, c){
    console.log(&#39;this&#39;, this)
    console.log(a, b, c)
    return &#39;this is fn1&#39;
}
const fn2 = fn1.bind1({x: 100}, 10, 20, 30)
const res = fn2()
console.log(res)
</code></pre>
<h3 id="四、手写-new"><a href="#四、手写-new" class="headerlink" title="四、手写 new"></a>四、手写 new</h3><pre><code class="js">function funcNew(obj, ...args) {
    const newObj = Object.create(obj.prototype);
    const result = obj.apply(newObj, args);
    return (typeof result === &#39;object&#39; &amp;&amp; result !== null) ? result : newObj;
}
</code></pre>
<p>new 一个实例会受到返回值的影响，比如：</p>
<pre><code class="js">/**
 * --- Person 中 return 一个对象，p 为该对象 ---
 */

function Person(name) {
    this.name = name;
    return {age: 35}
}

Person.prototype.sayName = function() {
    console.log(this.name);
} 

const p = new Person(&#39;orange&#39;)
console.log(p) // { age: 35 }
console.log(p.name) // undefined
p.sayName(); // TypeError: p.sayName is not a function

/**
 * --- Person 返回非对象，return 不影响结果 ---
 */

function Person(name) {
    this.name = name;
    return &#39;free&#39;
}

Person.prototype.sayName = function() {
    console.log(this.name);
} 

const p = new Person(&#39;orange&#39;)
console.log(p) // Person { name: &#39;orange&#39; }
console.log(p.name) // orange
p.sayName(); // orange
</code></pre>
<h3 id="五、手写-instanceof"><a href="#五、手写-instanceof" class="headerlink" title="五、手写 instanceof"></a>五、手写 instanceof</h3><pre><code class="js">/*
 * --- 手动实现 instanceof ---
 */

function newInstanceOf (leftValue, rightValue) {
    if (typeof leftValue !== &#39;object&#39; || rightValue == null) { 
        return false;
    }

    let rightProto = rightValue.prototype;
    leftValue = leftValue.__proto__;

    while (true) {
        if (leftValue === null) return false;
        if (leftValue === rightProto) return true;
        leftValue = leftValue.__proto__;
    }
}

/*
 * --- 验证 ---
 */

const a = [];
const b = {};

function Foo () {}

var c = new Foo()
function Child () {}
function Father() {}
Child.prototype = new Father()
var d = new Child()

console.log(newInstanceOf(a, Array)) // true
console.log(newInstanceOf(b, Object)) // true
console.log(newInstanceOf(b, Array)) // false
console.log(newInstanceOf(a, Object)) // true
console.log(newInstanceOf(c, Foo)) // true
console.log(newInstanceOf(d, Child)) // true
console.log(newInstanceOf(d, Father)) // true
console.log(newInstanceOf(123, Object)) // false 
console.log(123 instanceof Object) // false
</code></pre>
<p>这个问题既考察了 instanceof 的原理，又考察了原型链，还考察了代码能力，是一个好问题。在实现代码中，我们判断 leftValue 是否为 rightValue 的实例，思想是在 leftValue 的原型链上，即 leftValue.<strong>proto</strong> 上寻找是否存在 rightValue.prototype。</p>
<h3 id="六、实现-Promise-all"><a href="#六、实现-Promise-all" class="headerlink" title="六、实现 Promise.all()"></a>六、实现 Promise.all()</h3><p>1、接收一个 Promise 实例的数组或具有 Iterator 接口的对象，</p>
<p>2、如果元素不是 Promise 对象，则使用 Promise.resolve 转成 Promise 对象</p>
<p>3、如果全部成功，状态变为 resolved，返回值将组成一个数组传给回调</p>
<p>4、只要有一个失败，状态就变为 rejected，返回值将直接传递给回调all() 的返回值也是新的 Promise 对象</p>
<pre><code class="js">function promiseAll(promises) {
  return new Promise(function(resolve, reject) {
    if (!isArray(promises)) {
      return reject(new TypeError(&#39;arguments must be an array&#39;));
    }
    var resolvedCounter = 0;
    var promiseNum = promises.length;
    var resolvedValues = new Array(promiseNum);
    for (var i = 0; i &lt; promiseNum; i++) {
        (function(i) {
            Promise.resolve(promises[i]).then(function(value) {
            resolvedCounter++
            resolvedValues[i] = value
            if (resolvedCounter == promiseNum) {
                return resolve(resolvedValues)
            }
            }, function(reason) {
            return reject(reason)
            })
        })(i)
    }
  })
}
</code></pre>
]]></content>
      <categories>
        <category>笔记</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端</tag>
        <tag>面试题</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>笔记</title>
    <url>/2022/02/23/note/index/</url>
    <content><![CDATA[<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><h3 id="父-gt-子"><a href="#父-gt-子" class="headerlink" title="父 =&gt; 子"></a>父 =&gt; 子</h3><p> props</p>
<pre><code class="js">// child
props: { msg: String }

// parent
&lt;helloWorld msg=&quot;welcome&quot; /&gt;
</code></pre>
<p> $refs</p>
<pre><code class="js">// parent
&lt;helloWorld msg=&quot;welcome&quot; ref=&quot;helloWorld&quot; /&gt;
this.$refs.helloWorld.xx = &#39;xxx&#39;
</code></pre>
<p> $children</p>
<pre><code class="js">// parent $children不保证子组件顺序
this.$children[0].xx = &#39;xxx&#39;
</code></pre>
<h3 id="子-gt-父"><a href="#子-gt-父" class="headerlink" title="子 =&gt; 父"></a>子 =&gt; 父</h3><p> $emit</p>
<pre><code class="js">// child
this.$emit(&#39;add&#39;, &#39;msg&#39;)

// parent
&lt;helloWorld @add=&quot;add&quot; /&gt;
</code></pre>
<h3 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h3><p> $parent / $root</p>
<pre><code class="js">// brother1 监听
this.$parent.$on(&#39;foo&#39;, &#39;msg&#39;)
// brother1 派发
this.$parent.$emit(&#39;foo&#39;)
</code></pre>
<h3 id="祖先后代组件通信"><a href="#祖先后代组件通信" class="headerlink" title="祖先后代组件通信"></a>祖先后代组件通信</h3><p>注：官方不建议项目使用，并且不建议修改</p>
<pre><code class="js">// 祖
provide() {
  return {
    foo: &#39;foo&#39;
  }
}

// 后
inject: [&#39;foo&#39;]
</code></pre>
<h3 id="任意两个组件通信"><a href="#任意两个组件通信" class="headerlink" title="任意两个组件通信"></a>任意两个组件通信</h3><pre><code class="js">Vue.prototype.$bus = new Vue()

// child1
this.$bus.$on(&#39;foo&#39;, handle)
// child2
this.$bus.$emit(&#39;foo&#39;, &#39;msg&#39;)
</code></pre>
<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><pre><code class="js">// 匿名插槽
&lt;div&gt;
  &lt;slot&gt;&lt;/slot&gt;
&lt;/div&gt;
&lt;helloWorld&gt;
  &lt;template v-slot:default&gt;&lt;/template&gt;
&lt;/helloWorld&gt;

// 具名插槽
&lt;div&gt;
  &lt;slot name=&quot;main&quot;&gt;&lt;/slot&gt;
&lt;/div&gt;
&lt;helloWorld&gt;
  &lt;template v-slot:main&gt;&lt;/template&gt;
&lt;/helloWorld&gt;

// 作用域插槽
&lt;div&gt;
  &lt;slot name=&quot;main&quot; msg=&quot;msg&quot;&gt;&lt;/slot&gt;
&lt;/div&gt;
&lt;helloWorld&gt;
  &lt;template v-slot:main={msg}&gt;{{ msg }}&lt;/template&gt;
&lt;/helloWorld&gt;
</code></pre>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>sortable+element实现表格行拖拽</title>
    <url>/2020/04/07/sortable-element-drag/index/</url>
    <content><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code class="bash">npm install vuedraggable
</code></pre>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><pre><code class="js">import Sortable from &#39;sortablejs&#39;
</code></pre>
<h3 id="el-table-添加row-key属性"><a href="#el-table-添加row-key属性" class="headerlink" title="el-table 添加row-key属性"></a>el-table 添加row-key属性</h3><pre><code class="html">&lt;el-table
  ref=&quot;filterTable&quot;
  row-key=&quot;ip&quot; 
  @filter-change=&quot;handlerFilterChange&quot; 
  class=&quot;cl-table&quot; 
  :data=&quot;resourceList&quot; 
  v-loading=&quot;resourceListLoading&quot; 
  stripe
  style=&quot;width:100%;&quot;&gt;
  &lt;el-table-column
    prop=&quot;name&quot;
    label=&quot;主机名&quot; 
    :min-width=&quot;150&quot; 
    show-overflow-tooltip&gt;
  &lt;/el-table-column&gt;
&lt;/el-table&gt;
</code></pre>
<h3 id="将拖拽元素设置为要拖动项的父级元素"><a href="#将拖拽元素设置为要拖动项的父级元素" class="headerlink" title="将拖拽元素设置为要拖动项的父级元素"></a>将拖拽元素设置为要拖动项的父级元素</h3><pre><code class="js">mounted() {
  // 表格中需要实现行拖动，所以选中tr的父级元素
  const table = document.querySelector(&#39;.el-table__body-wrapper tbody&#39;)
  const self = this
  Sortable.create(table, {
    onEnd({ newIndex, oldIndex }) {
      console.log(newIndex, oldIndex)
      const targetRow = self.resourceList.splice(oldIndex, 1)[0]
      self.resourceList.splice(newIndex, 0, targetRow)
    }
  })
}
</code></pre>
]]></content>
      <categories>
        <category>VUE</category>
        <category>element</category>
      </categories>
      <tags>
        <tag>VUE</tag>
        <tag>element</tag>
        <tag>table</tag>
        <tag>拖拽</tag>
      </tags>
  </entry>
  <entry>
    <title>手写notice弹窗组件</title>
    <url>/2022/02/25/notice-component/index/</url>
    <content><![CDATA[<h2 id="手写notice弹窗组件"><a href="#手写notice弹窗组件" class="headerlink" title="手写notice弹窗组件"></a>手写notice弹窗组件</h2><p>notice.vue</p>
<pre><code class="vue">&lt;template&gt;
  &lt;div v-if=&quot;isShow&quot;&gt;
    &lt;p&gt;{{title}}&lt;/p&gt;
    &lt;p&gt;{{text}}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  props: {
    title: {
      type: String,
      default: &#39;&#39;
    },
    text: {
      type: String,
      default: &#39;&#39;
    },
    time: {
      type: Number,
      default: 0
    }
  },
  data() {
    return {
      isShow: false
    }
  },
  methods: {
    show() {
      this.isShow = true;
      this.time &amp;&amp; setTimeout(() =&gt; {
        this.hide();
      }, this.time)
    },
    hide() {
      this.isShow = false;
      this.remove();
    }
  }
}
&lt;/script&gt;
</code></pre>
<p>create.js</p>
<pre><code class="js">import Vue from &quot;vue&quot;;

export default function create(component, props) {
  // 创建vue实例
  const vm = new Vue({
    render(h) {
      return h(component, {props})
    }
  }).$mount();
  // 获取组件实例
  const comp = vm.$children[0];
  // 组件实例追加到body
  document.body.appendChild(vm.$el);
  // 清理函数
  comp.remove = () =&gt; {
    document.body.removeChild(vm.$el);
    vm.$destroy();
  }
  // 返回组件实例
  return comp;
}
</code></pre>
<p>使用notice组件</p>
<pre><code class="js">const notice = Create(Notice, {
  title: &#39;登录&#39;,
  text: &#39;正确！&#39;,
  time: 3000
})
notice.show();
</code></pre>
]]></content>
      <categories>
        <category>notice弹窗组件</category>
      </categories>
      <tags>
        <tag>组件</tag>
        <tag>notice</tag>
        <tag>弹窗</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack配置全局svg图标</title>
    <url>/2022/03/17/svg-webpack/index/</url>
    <content><![CDATA[<h2 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h2><pre><code class="js">const { defineConfig } = require(&#39;@vue/cli-service&#39;)
const path = require(&#39;path&#39;)
function resolve(dir) {
  return path.join(__dirname, dir)
}
const port = 7070;
const title = &#39;webpack测试&#39;;
module.exports = defineConfig({
  transpileDependencies: true,
  lintOnSave: false, // 是否在开发环境下每次保存代码时都启用 eslint验证
  devServer: {
    port: port
  },
  chainWebpack(config) {
    config.module.rule(&#39;svg&#39;)
      .exclude.add(resolve(&#39;src/assets&#39;))

    // 添加svg-sprite-loader
    config.module.rule(&#39;svg-icon&#39;)
      .test(/\.svg$/)
      .include.add(resolve(&#39;src/assets&#39;))
        .end()
      .use(&#39;svg-sprite-loader&#39;) //  添加loader
        .loader(&#39;svg-sprite-loader&#39;)//  切换上下文到loader
        .options({symbolId: &#39;icon-[name]&#39;})
        .end()
  }
})
</code></pre>
<h2 id="icon-vue"><a href="#icon-vue" class="headerlink" title="icon.vue"></a>icon.vue</h2><pre><code class="vue">&lt;template&gt;
  &lt;div class=&quot;icon&quot;&gt;
    &lt;svg&gt;
      &lt;use :xlink:href=&quot;iconName&quot; :class=&quot;svgClass&quot;&gt;&lt;/use&gt;
    &lt;/svg&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot;&gt;
import { Component, Vue, Prop } from &#39;vue-property-decorator&#39;;
@Component({
  components: {
  },
})
export default class HomeView extends Vue {
  @Prop() private iconClass!: string;
  @Prop() private className!: string;

  get iconName(): string {
    return `#icon-${this.iconClass}`;
  }

  get svgClass(): string {
    if(this.className) {
      return `icon-svg ${this.className}`;
    }
    return &#39;icon-svg&#39;;
  }
}
&lt;/script&gt;
&lt;style scoped&gt;
.icon-svg {

}
&lt;/style&gt;
</code></pre>
<h2 id="icon-js"><a href="#icon-js" class="headerlink" title="icon.js"></a>icon.js</h2><pre><code class="js">import Vue from &quot;vue&quot;;
import Icon from &#39;@/components/icon.vue&#39;
// 图标自动导入
// 利用webpack 的require.context自动导入

// 返回的req是只去加载svg目录中的模块的函数
const req = require.context(&#39;./svg&#39;, false, /\.svg$/) //  路径， 是否递归， 匹配规则

req.keys().map(req);

Vue.component(&#39;Icon&#39;, Icon)
</code></pre>
<h2 id="main-js-引用icon-js"><a href="#main-js-引用icon-js" class="headerlink" title="main.js 引用icon.js"></a>main.js 引用icon.js</h2><pre><code class="js">import &#39;@/assets/index&#39;
</code></pre>
<h2 id="home-vue-使用icon"><a href="#home-vue-使用icon" class="headerlink" title="home.vue 使用icon"></a>home.vue 使用icon</h2><pre><code class="vue">&lt;template&gt;
  &lt;div class=&quot;home&quot;&gt;
    &lt;icon icon-class=&quot;wx&quot;&gt;&lt;/icon&gt;
    &lt;icon icon-class=&quot;qq&quot;&gt;&lt;/icon&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot;&gt;
import { Component, Vue } from &#39;vue-property-decorator&#39;;

@Component({
  components: {}
})
export default class HomeView extends Vue {}
&lt;/script&gt;

</code></pre>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>svg</tag>
        <tag>图标</tag>
      </tags>
  </entry>
  <entry>
    <title>vite配置全局svg图标</title>
    <url>/2022/04/07/svg-vite/index/</url>
    <content><![CDATA[<h2 id="vite-config-ts配置"><a href="#vite-config-ts配置" class="headerlink" title="vite.config.ts配置"></a>vite.config.ts配置</h2><pre><code class="js">import path from &#39;path&#39;;
import { createSvgIconsPlugin } from &#39;vite-plugin-svg-icons&#39;;
export default defineConfig(env =&gt; {
  return {
    plugins: [
      createSvgIconsPlugin({
        // 指定要缓存的图标文件夹
        iconDirs: [path.resolve(process.cwd(), &#39;src/render/assets/svg&#39;)],
        // 执行icon name的格式
        symbolId: &#39;icon-[dir]-[name]&#39;,
      })
    ]
  }
})
</code></pre>
<h2 id="SvgIcon-vue"><a href="#SvgIcon-vue" class="headerlink" title="SvgIcon.vue"></a>SvgIcon.vue</h2><pre><code class="vue">&lt;template&gt;
  &lt;svg :class=&quot;svgClass&quot; aria-hidden=&quot;true&quot;&gt;
    &lt;use :xlink:href=&quot;iconName&quot; :fill=&quot;color&quot; /&gt;
  &lt;/svg&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot;&gt;
import { defineComponent, computed } from &#39;vue&#39;;
export default defineComponent({
  props: {
    iconClass: {
      type: String,
      required: true
    },
    className: {
      type: String,
      default: &#39;&#39;
    },
    color: {
      type: String,
      default: &#39;&#39;
    },
  },
  setup(props) {
    return {
      iconName: computed(() =&gt; `#icon-${props.iconClass}`),
      svgClass: computed(() =&gt; {
        if (props.className) {
          return `svg-icon ${props.className}`
        }
        return &#39;svg-icon&#39;
      })
    }
  }
})
&lt;/script&gt;

&lt;style scoped&gt;
.svg-icon {
  width: 1em;
  height: 1em;
  position: relative;
  fill: currentColor;
  vertical-align: -2px;
}
&lt;/style&gt;
</code></pre>
<h2 id="main-js-引用SvgIcon-vue"><a href="#main-js-引用SvgIcon-vue" class="headerlink" title="main.js 引用SvgIcon.vue"></a>main.js 引用SvgIcon.vue</h2><pre><code class="js">import { createApp } from &#39;vue&#39;
import App from &#39;./App.vue&#39;
import &#39;virtual:svg-icons-register&#39;;
import SvgIcon from &#39;@/render/components/svgIcon/SvgIcon.vue&#39;;
const app = createApp(App);
app.component(&#39;svg-icon&#39;,SvgIcon);
</code></pre>
<h2 id="home-vue-使用SvgIcon"><a href="#home-vue-使用SvgIcon" class="headerlink" title="home.vue 使用SvgIcon"></a>home.vue 使用SvgIcon</h2><pre><code class="vue">&lt;template&gt;
  &lt;div class=&quot;home&quot;&gt;
    &lt;svg-icon iconClass=&quot;noNet&quot; className=&quot;className&quot; /&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>svg</tag>
        <tag>图标</tag>
        <tag>vite</tag>
      </tags>
  </entry>
  <entry>
    <title>viewPort适配移动端</title>
    <url>/2020/04/07/viewPort/index/</url>
    <content><![CDATA[<h3 id="PostCSS-基本插件"><a href="#PostCSS-基本插件" class="headerlink" title="PostCSS 基本插件"></a>PostCSS 基本插件</h3><p>默认安装vue-cli 脚手架</p>
<pre><code class="js">module.exports = {
   &quot;plugins&quot;: {
   &quot;postcss-import&quot;: {},
        &quot;postcss-url&quot;: {},
        // to edit target browsers: use &quot;browserslist&quot; field in package.json
        &quot;autoprefixer&quot;: {}
    }
}
</code></pre>
<h3 id="PostCSS-其他插件"><a href="#PostCSS-其他插件" class="headerlink" title="PostCSS 其他插件"></a>PostCSS 其他插件</h3><p>安装其他插件</p>
<pre><code class="bash">npm i postcss-aspect-ratio-mini postcss-px-to-viewport postcss-write-svg postcss-cssnext postcss-viewport-units cssnano --S
</code></pre>
<p>安装成功之后 package.json 显示：</p>
<pre><code class="js">&quot;dependencies&quot;: {
    &quot;axios&quot;: &quot;^0.18.0&quot;,
    &quot;cssnano&quot;: &quot;^4.1.0&quot;,
    &quot;postcss-aspect-ratio-mini&quot;: &quot;0.0.2&quot;,
    &quot;postcss-cssnext&quot;: &quot;^3.1.0&quot;,
    &quot;postcss-px-to-viewport&quot;: &quot;0.0.3&quot;,
    &quot;postcss-viewport-units&quot;: &quot;^0.1.4&quot;,
    &quot;postcss-write-svg&quot;: &quot;^3.0.1&quot;,
    &quot;vue&quot;: &quot;^2.5.2&quot;,
    &quot;vue-router&quot;: &quot;^3.0.1&quot;,
    &quot;vuex&quot;: &quot;^3.0.1&quot; 
}
</code></pre>
<h3 id="postcssrc-js-文件设置"><a href="#postcssrc-js-文件设置" class="headerlink" title=".postcssrc.js 文件设置"></a>.postcssrc.js 文件设置</h3><p>脚手架原有的三个配置项需要注释 autoprefixer ，理由是 cssnano 中已经具有此配置</p>
<pre><code class="js">module.exports = {
    &quot;plugins&quot;: {
        &quot;postcss-import&quot;: {},
        &quot;postcss-url&quot;: {},
        // to edit target browsers: use &quot;browserslist&quot; field in package.json
        // &quot;autoprefixer&quot;: {}, 
        &quot;postcss-aspect-ratio-mini&quot;: {},
        &quot;postcss-write-svg&quot;: {
            utf8: false
        },
        &quot;postcss-cssnext&quot;: {},
        &quot;postcss-px-to-viewport&quot;: {
            viewportWidth: 750, // 视窗的宽度，对应的是我们设计稿的宽度，一般是750
            // viewportHeight: 1334, // 视窗的高度，根据750设备的宽度来指定，一般指定1334，也可以不设置
            unitPrecision: 3, // 指定`px`转换为视窗单位值的小数位数（很多时候无法整除）
            viewportUnit: &#39;vw&#39;, // 指定需要转换成的视窗单位，建议使用vw
            selectorBlackList: [&#39;.ignore&#39;, &#39;.hairlines&#39;], // 指定不转换为视窗单位的类，可以自定义， 可以无限添加,建议定义一至两个通用的类名 
            minPixelValue: 1, // 小于或等于`1px`不转换为视窗单位，你也可以设置为你想要的值
            mediaQuery: false // 允许在媒体查询中转换`px`
        },
        &quot;postcss-viewport-units&quot;: {},
        &quot;cssnano&quot;: {
            preset: &quot;advanced&quot;,
            autoprefixer: false,
            &quot;postcss-zindex&quot;: false
        }
    }
}
</code></pre>
<h3 id="cssnano-插件安装"><a href="#cssnano-插件安装" class="headerlink" title="cssnano 插件安装"></a>cssnano 插件安装</h3><p>在配置中我们使用了 preset: “advanced” ，所以还需要安装</p>
<pre><code class="bash">npm i cssnano-preset-advanced --save-dev
</code></pre>
<p>基本配置</p>
<pre><code class="js">&quot;cssnano&quot;: {
    preset: &quot;advanced&quot;,
    autoprefixer: false,
    &quot;postcss-zindex&quot;: false
}
</code></pre>
<h3 id="postcss-px-to-viewport"><a href="#postcss-px-to-viewport" class="headerlink" title="postcss-px-to-viewport"></a>postcss-px-to-viewport</h3><p>这是核心的插件，帮助我们将 px 转成 vw、vh、vmin、vmax<br>目前出视觉设计稿，都是使用 750px，那么 100vw = 750px，即 1vw = 7.5px。那么我们根据设计图上 的px 值直接转换成对于的 vw 值。实际撸码过程中，不需要做任何计算，直接在代码中写 px 即可</p>
]]></content>
      <categories>
        <category>VUE</category>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>VUE</tag>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-element-table-滚动加载</title>
    <url>/2020/04/07/vue-element-table_rolling-load/index/</url>
    <content><![CDATA[<p>首先在main.js文件注册全局事件，代码如下：</p>
<pre><code class="js">Vue.directive(&#39;loadmore&#39;, {
  bind(el, binding) {
    var p = 0;
    var t = 0;
    var down = true;
    var selectWrap = el.querySelector(&#39;.el-table__body-wrapper&#39;)
    selectWrap.addEventListener(&#39;scroll&#39;, function() {
      //判断是否向下滚动
      p = this.scrollTop;
      // if ( t &lt; p){down=true}else{down=false}
      if(t &lt; p){
        down = true;
      }else{
        down = false;
      }
      t = p;
      //判断是否到底
      const sign = 10;
      const scrollDistance = this.scrollHeight - this.scrollTop - this.clientHeight
      if (scrollDistance &lt;= sign &amp;&amp; down) {
        binding.value()
      }
    })
  }
})
</code></pre>
<p>在组件中，使用自定义的事件：<br>v-loadmore=”loadMore”<br>在methods中调用loadMore<br>这样就实现啦！！！</p>
]]></content>
      <categories>
        <category>VUE</category>
        <category>element</category>
      </categories>
      <tags>
        <tag>VUE</tag>
        <tag>element</tag>
        <tag>table</tag>
        <tag>滚动加载</tag>
      </tags>
  </entry>
  <entry>
    <title>vue异步更新机制</title>
    <url>/2022/02/21/vue-asynchronous-update-mechanism/index/</url>
    <content><![CDATA[<h2 id="vue异步更新机制"><a href="#vue异步更新机制" class="headerlink" title="vue异步更新机制"></a>vue异步更新机制</h2><p>vue中更新dom是异步执行的，只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。（先缓冲，缓冲后再将多次触发属性的最后一次作为promise放入队列；而不是一上来就放队列）</p>
<p>vue中数据的更新到dom是异步的，数据的异步更新可以理解成一个promise的微任务；并且对同一个属性值进行多次赋值时，只有最后一次赋值会作为一个promise微任务放到更新队列。</p>
<pre><code class="vue">&lt;template&gt;
  &lt;div id=&quot;example&quot;&gt;{{message}}&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  var vm = new Vue({
    el: &#39;#example&#39;,
    data: {
      message: &#39;123&#39;
    }
  })

  Promise.resolve(1).then(value =&gt; {
    console.log(&quot;xxx&quot;, vm.$el.textContent);     // 第二步输出：123
  })

  vm.message = &#39;msg&#39; // 更改数据

  Promise.resolve(2).then(value =&gt; {
    console.log(&quot;测试&quot;, vm.$el.textContent);  // 第三步输出：new
  })

  vm.message = &#39;new&#39; // 更改数据

  Promise.resolve(3).then(value =&gt; {
    console.log(&quot;fff&quot;, vm.$el.textContent);         // 第四步输出：new
  })

  console.log(vm.$el.textContent);          // 第一步输出：123
&lt;/script&gt;
</code></pre>
]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
        <tag>异步更新机制</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-property-decorator用法</title>
    <url>/2022/03/17/vue-property-decorator/index/</url>
    <content><![CDATA[<h3 id="vue-property-decorator"><a href="#vue-property-decorator" class="headerlink" title="vue-property-decorator"></a>vue-property-decorator</h3><h4 id="data"><a href="#data" class="headerlink" title="data"></a>data</h4><pre><code class="vue">&lt;script lang=&quot;ts&quot;&gt;
    import {Vue, Component} from &#39;vue-property-decorator&#39;;

    @Component({})
    export default class &quot;组件名&quot; extends Vue{
        ValA: string = &quot;hello world&quot;;
        ValB: number = 1;
    }
&lt;/script&gt;
</code></pre>
<h4 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h4><pre><code class="vue">&lt;script lang=&quot;ts&quot;&gt;
    import {Vue, Component} from &#39;vue-property-decorator&#39;;

    @Component({})
    export default class &quot;组件名&quot; extends Vue{
        get ValA(){
            return 1;
        }
    }
&lt;/script&gt;
</code></pre>
<h4 id="Emit"><a href="#Emit" class="headerlink" title="Emit"></a>Emit</h4><p>@Emit()不传参数,那么它触发的事件名就是它所修饰的函数名.<br>@Emit(name: string),里面传递一个字符串,该字符串为要触发的事件名.</p>
<pre><code class="vue">&lt;script lang=&quot;ts&quot;&gt;
    import {Vue, Component, Emit} from &#39;vue-property-decorator&#39;;

    @Component({})
    export default class &quot;组件名&quot; extends Vue{
        mounted(){
            this.$on(&#39;emit-todo&#39;, function(n) {
                console.log(n)
            })

            this.emitTodo(&#39;world&#39;);
        }

            @Emit()
        emitTodo(n: string){
            console.log(&#39;hello&#39;);
        }
    }
&lt;/script&gt;
</code></pre>
<h4 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch</h4><pre><code class="vue">&lt;script&gt;
import {Vue, Component, Watch} from &#39;vue-property-decorator&#39;;

@Watch(&#39;child&#39;)
onChangeValue(newVal: string, oldVal: string){
    // todo...
}

@Watch(&#39;person&#39;, {immediate: true, deep: true})
onChangeValue(newVal: Person, oldVal: Person){
    // todo...
}
&lt;/script&gt;
</code></pre>
<h4 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h4><pre><code class="vue">&lt;script lang=&quot;ts&quot;&gt;
    import {Vue, Component, Prop} from &#39;vue-property-decorator&#39;;

    @Component({})
    export default class &quot;组件名&quot; extends Vue{
        @Prop(Number) propA!: number;
        @Prop({default: &#39;default value&#39;}) propB!: string;
        @propC([String, Boolean]) propC: string | boolean;
    }
&lt;/script&gt;
</code></pre>
<h4 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h4><p>一种是vue-class-component提供的.</p>
<pre><code class="vue">&lt;script&gt;
import  Component  {mixins}  from &#39;vue-class-component&#39;;
import myMixins from &#39;mixins.ts&#39;;

@Component
// 直接extends myMinxins 也可以正常运行
export class myComponent extends mixins(myMixins) {
      created(){
          console.log(this.value) // =&gt; Hello
    }
}
&lt;/script&gt;
</code></pre>
<p>第二种方式是在@Component中混入.</p>
<pre><code class="vue">&lt;script&gt;
import { Vue, Component, Prop } from &#39;vue-property-decorator&#39;;
import myMixins from &#39;@static/js/mixins&#39;;

@Component({
    mixins: [myMixins]
})
export default class myComponent extends Vue{
    created(){
        console.log(this.value) // =&gt; Hello
    }
}
&lt;/script&gt;
</code></pre>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-property-decorator</tag>
        <tag>ts</tag>
      </tags>
  </entry>
  <entry>
    <title>简单实现vue双向绑定以及v-text、v-model、v-html、@click、插值表达式</title>
    <url>/2022/03/11/vuejs/index/</url>
    <content><![CDATA[<h2 id="html页面"><a href="#html页面" class="headerlink" title="html页面"></a>html页面</h2><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Vue&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script src=&quot;Untitled-1.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;Compile.js&quot;&gt;&lt;/script&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;p&gt;{{name}}&lt;/p&gt;
    &lt;p v-text=&quot;name&quot;&gt;&lt;/p&gt;
    &lt;p&gt;{{age}}&lt;/p&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;model&quot;&gt;
    &lt;div v-html=&quot;html&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;script&gt;
    const app = new Vue({
      el: &#39;#app&#39;,
      data: {
        name: &#39;jina&#39;,
        // obj: {
        //   age: 18
        // },
        age: 12,
        model: &#39;aaa&#39;,
        html: &#39;&lt;button @click=&quot;click&quot;&gt;这是一个按钮&lt;/button&gt;&#39;
      },
      created() {
        // setTimeout(() =&gt; {
        //   this.name = &#39;修改测试&#39;
        // }, 2000);
      },
      metheds: {
        click() {
          this.name = &#39;jierui&#39;;
          console.log(this.name);
        }
      }
    })
    // app.name = &#39;zong&#39;;
    // app.obj.age = 12;
    // console.log(app.$data);
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="实现Vue构造函数"><a href="#实现Vue构造函数" class="headerlink" title="实现Vue构造函数"></a>实现Vue构造函数</h2><pre><code class="js">class Vue {
  constructor(options) {
    // 保存数据
    this.$options = options;
    // 传入data
    this.$data = options.data;
    this.$metheds = options.metheds;
    // 响应化处理
    this.observe(this.$data);

    // Watcher 测试
    // new Watcher(this, &#39;name&#39;);
    // this.name;
    // new Watcher(this, &#39;obj.age&#39;);
    // this.obj.age;

    // 编译器测试
    new Compile(options.el, this);

    if (options.created) {
      options.created.call(this);
    }
  }

  observe(data) {
    // 暂不考虑数组和函数
    if (!data || typeof data !== &#39;object&#39;) return;
    Object.keys(data).forEach(key =&gt; {
      this.defineReactive(data, key, data[key]);
      // 代理data中的属性到vue根上
      this.proxyData(key);
    })
  }

  defineReactive(data, key, value) {
    // 递归处理
    this.observe(value);
    // 定义一个Dep
    const dep = new Dep();
    // 给data中的每个key定义拦截
    Object.defineProperty(data, key, {
      get() {
        // 收集依赖
        Dep.target &amp;&amp; dep.addDep(Dep.target);
        return value;
      },
      set(newValue) {
        if (newValue !== value) {
          value = newValue;
          console.log(key + &#39; 数据更新！&#39;)
          dep.notify();
        }
      }
    })
  }

  proxyData(key) {
    Object.defineProperty(this, key, {
      get() {
        return this.$data[key];
      },
      set(newValue) {
        this.$data[key] = newValue;
      }
    })
  }
}

// 创建dep 管理所有watcher
class Dep {
  constructor() {
    // 存储所有依赖
    this.watchers = [];
  }

  addDep(watcher) {
    this.watchers.push(watcher);
  }

  notify() {
    this.watchers.forEach(watcher =&gt; watcher.update())
  }
}

// 创建watcher 保存data中数值和页面中的挂钩关系
class Watcher {
  constructor(vm, key, cb) {
    this.vm= vm;
    this.key = key;
    this.cb = cb;
    // 创建实例时 立刻将该实例指向静态属性Dep.target便于依赖收集
    Dep.target = this;
    this.vm[key];
    Dep.target = null;
  }

  update() {
    console.log(this.key + &#39;更新了！&#39;);
    this.cb.call(this.vm, this.vm[this.key]);
  }
}
</code></pre>
<h2 id="实现Compile构造函数"><a href="#实现Compile构造函数" class="headerlink" title="实现Compile构造函数"></a>实现Compile构造函数</h2><pre><code class="js">// 遍历dom结构，解析指令和插值表达式
class Compile {
  // el: 待编译模板  vm: Vue实例
  constructor(el, vm) {
    this.$el = document.querySelector(el);
    this.$vm = vm;

    // 把模板中的内容移到片段操作
    this.$fragment = this.nodeFragment(this.$el);
    // 执行编译器
    this.compile(this.$fragment);
    // 放回$el中
    this.$el.appendChild(this.$fragment);
  }

  nodeFragment(el) {
    /*
      DocumentFragments 是DOM节点。它们不是主DOM树的一部分。
      通常的用例是创建文档片段，将元素附加到文档片段，然后将文档片段附加到DOM树。
      在DOM树中，文档片段被其所有的子元素所代替。
      因为文档片段存在于内存中，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面回流（对元素位置和几何上的计算）。
      因此，使用文档片段通常会带来更好的 性能 
    */
   const fragment = document.createDocumentFragment();
   let child;
   while (child = el.firstChild) {
     fragment.appendChild(child);
   }
   return fragment;
  }

  compile(el) {
    const childNodes = el.childNodes;
    Array.from(childNodes).forEach(node =&gt; {
      if (node.nodeType === 1) {
        // 元素
        console.log(&#39;编译元素&#39; + node.nodeName);
        this.compileElement(node);
      } else if (this.isInter(node)) {
        // 文本
        console.log(&#39;编译插值文本&#39; + node.textContent);
        this.compileText(node);
      }
      // 递归子节点
      if (node.children &amp;&amp; node.childNodes.length &gt; 0) {
        this.compile(node);
      }
    })
  }

  // 正则表达式解析是否为文本
  isInter(node) {
    return node.nodeType === 3 &amp;&amp; /\{\{(.*)\}\}/.test(node.textContent)
  }

  // 文本编译
  compileText(node) {
    const exp = RegExp.$1;
    this.update(node, exp, &#39;text&#39;);
    node.textContent = this.$vm[RegExp.$1];
  }

  // 元素编译
  compileElement(node) {
    const nodeAttrs = node.attributes;
    Array.from(nodeAttrs).forEach(attr =&gt; {
      // v-xxx=&quot;yyy&quot;
      const attrName = attr.name;// v-xxx
      const exp = attr.value;// yyy
      if (attrName.indexOf(&#39;v-&#39;) === 0) {
        const dir = attrName.substring(2);
        this[dir] &amp;&amp; this[dir](node, exp, dir);
      } else if (attrName === &#39;@click&#39;) {
        const _this = this;
        node.addEventListener(&#39;click&#39;, function() {
          _this.$vm.$metheds[exp].call(_this.$vm);
        })
      }
    })
  }

  // 更新
  update(node, exp, dir) {
    const updator = this[dir + &#39;Updator&#39;];
    updator &amp;&amp; updator(node, this.$vm[exp]);
    new Watcher(this.$vm, exp, function(value) {
      updator &amp;&amp; updator(node, value);
    });
  }

  // v-text 更新处理
  text(node, exp, dir) {
    this.update(node, exp, dir)
  }
  // 修改文本的值
  textUpdator(node, value) {
    node.textContent = value;
  }

  // v-html
  html(node, exp, dir) {
    this.update(node, exp, dir)
  }
  htmlUpdator(node, value) {
    node.innerHTML = value;
  }

  // v-model
  model(node, exp, dir) {
    this.update(node, exp, dir);
    const _this = this;
    node.addEventListener(&#39;input&#39;, function(InputEvent) {
      _this.$vm[exp] = InputEvent.target.value;
    })
  }
  modelUpdator(node, value) {
    node.value = value;
  }

}
</code></pre>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>原理</tag>
        <tag>vue</tag>
        <tag>双向绑定</tag>
      </tags>
  </entry>
</search>
