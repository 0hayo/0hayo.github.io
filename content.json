{"meta":{"title":"0hayo","subtitle":null,"description":"站在自己所热爱的世界里！","author":"0hayo","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2022-11-21T05:58:54.585Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[なんでもないやの0hayo] 与&nbsp; 0hayo&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2022-11-21T06:29:21.625Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2022-11-21T05:58:54.585Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2022-11-21T05:58:54.585Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2022-11-21T05:58:54.585Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2022-11-21T05:58:54.585Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2022-11-21T05:58:54.585Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2022-11-21T05:58:54.585Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2022-11-21T06:29:31.857Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2022-11-21T05:58:54.585Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2022-11-21T05:58:54.585Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2022-11-21T05:58:54.585Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"vite配置全局svg图标","slug":"svg-vite/index","date":"2022-04-07T02:27:17.000Z","updated":"2022-11-21T06:41:36.191Z","comments":true,"path":"2022/04/07/svg-vite/index/","link":"","permalink":"/2022/04/07/svg-vite/index/","excerpt":"","text":"vite.config.ts配置import path from &#39;path&#39;; import { createSvgIconsPlugin } from &#39;vite-plugin-svg-icons&#39;; export default defineConfig(env =&gt; { return { plugins: [ createSvgIconsPlugin({ // 指定要缓存的图标文件夹 iconDirs: [path.resolve(process.cwd(), &#39;src/render/assets/svg&#39;)], // 执行icon name的格式 symbolId: &#39;icon-[dir]-[name]&#39;, }) ] } }) SvgIcon.vue&lt;template&gt; &lt;svg :class=&quot;svgClass&quot; aria-hidden=&quot;true&quot;&gt; &lt;use :xlink:href=&quot;iconName&quot; :fill=&quot;color&quot; /&gt; &lt;/svg&gt; &lt;/template&gt; &lt;script lang=&quot;ts&quot;&gt; import { defineComponent, computed } from &#39;vue&#39;; export default defineComponent({ props: { iconClass: { type: String, required: true }, className: { type: String, default: &#39;&#39; }, color: { type: String, default: &#39;&#39; }, }, setup(props) { return { iconName: computed(() =&gt; `#icon-${props.iconClass}`), svgClass: computed(() =&gt; { if (props.className) { return `svg-icon ${props.className}` } return &#39;svg-icon&#39; }) } } }) &lt;/script&gt; &lt;style scoped&gt; .svg-icon { width: 1em; height: 1em; position: relative; fill: currentColor; vertical-align: -2px; } &lt;/style&gt; main.js 引用SvgIcon.vueimport { createApp } from &#39;vue&#39; import App from &#39;./App.vue&#39; import &#39;virtual:svg-icons-register&#39;; import SvgIcon from &#39;@/render/components/svgIcon/SvgIcon.vue&#39;; const app = createApp(App); app.component(&#39;svg-icon&#39;,SvgIcon); home.vue 使用SvgIcon&lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;svg-icon iconClass=&quot;noNet&quot; className=&quot;className&quot; /&gt; &lt;/div&gt; &lt;/template&gt;","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"svg","slug":"svg","permalink":"/tags/svg/"},{"name":"图标","slug":"图标","permalink":"/tags/图标/"},{"name":"vite","slug":"vite","permalink":"/tags/vite/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"electron（send、sendSync、invoke）主进程与渲染进程通信的区别","slug":"electron-ipc/index","date":"2022-04-06T09:37:17.000Z","updated":"2022-11-21T06:44:12.538Z","comments":true,"path":"2022/04/06/electron-ipc/index/","link":"","permalink":"/2022/04/06/electron-ipc/index/","excerpt":"","text":"ipcRender.send渲染进程 render.js // render.js const { ipcRenderer } = require(&#39;electron&#39;); // send 方法发送，并绑定另一个事件接收返回值 function sendMessageToMain() { ipcRenderer.send(&#39;render-send-to-main&#39;, &#39;我是渲染进程通过 send 发送的消息&#39;); } ipcRenderer.on(&#39;main-reply-to-render&#39;, (event, message) =&gt; { console.log(&#39;replyMessage&#39;, message); // &#39;replyMessage 主进程通过 reply 回复给渲染进程的消息&#39; }) 主进程 main.js： // main.js const { ipcMain } = require(&#39;electron&#39;); ipcMain.on(&#39;render-send-to-main&#39;, (event, message) =&gt; { console.log(`receive message from render: ${message}`) event.reply(&#39;main-reply-to-render&#39;, &#39;主进程通过 reply 回复给渲染进程的消息&#39;) }) 1、主进程通过 ipcMain.on 来监听渲染进程的消息2、主进程接收到消息后，可以回复消息，也可以不回复。如果回复的话，通过 event.reply 发送另一个事件，渲染进程监听这个事件得到回复结果。如果不回复消息的话，渲染进程将接着执行 ipcRenderer.send 之后的代码 ipcRender.sendSync渲染进程 render.js： // render.js const { ipcRenderer } = require(&#39;electron&#39;); function sendSyncMessageToMain() { const replyMessage = ipcRenderer.sendSync(&#39;render-send-sync-to-main&#39;, &#39;我是渲染进程通过 syncSend 发送给主进程的消息&#39;); console.log(&#39;replyMessage&#39;, replyMessage); // &#39;主进程回复的消息&#39; } 主进程 main.js： // main.js const { ipcMain } = require(&#39;electron&#39;); ipcMain.on(&#39;render-send-sync-to-main&#39;, (event, message) =&gt; { console.log(`receive message from render: ${message}`) event.returnValue = &#39;主进程回复的消息&#39;; }) 1、主进程通过 ipcMain.on 来处理渲染进程发送的消息2、主进程通过 event.returnValue 回复渲染进程消息3、如果 event.returnValue 不为 undefined 的话，渲染进程会等待 sendSync 的返回值才执行后面的代码4、请保证 event.returnValue是有值的，否则会造成非预期的影响 ipcRender.invoke渲染进程 render.js： // render.js const { ipcRenderer } = require(&#39;electron&#39;); async function invokeMessageToMain() { const replyMessage = await ipcRenderer.invoke(&#39;render-invoke-to-main&#39;, &#39;我是渲染进程通过 invoke 发送的消息&#39;); console.log(&#39;replyMessage&#39;, replyMessage); } 主进程 main.js： // main.js const { ipcMain } = require(&#39;electron&#39;); ipcMain.handle(&#39;render-invoke-to-main&#39;, async (event, message) =&gt; { console.log(`receive message from render: ${message}`) const result = await asyncWork(); return result; }) const asyncWork = async () =&gt; { return new Promise(resolve =&gt; { setTimeout(() =&gt; { resolve(&#39;延迟 2 秒获取到主进程的返回结果&#39;) }, 2000) }) } 1、主进程通过 ipcMain.handle 来处理渲染进程发送的消息2、主进程接收到消息后，可以回复消息，也可以不回复。如果回复消息的话，可以通过 return 给渲染进程回复消息；如果不回复消息的话，渲染进程将接着执行 ipcRenderer.invoke 之后的代码3、渲染进程异步等待主进程的回应， invoke 的返回值是一个 Promise","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"electron","slug":"electron","permalink":"/tags/electron/"},{"name":"通信","slug":"通信","permalink":"/tags/通信/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"vue-property-decorator用法","slug":"vue-property-decorator/index","date":"2022-03-17T07:33:17.000Z","updated":"2022-11-21T06:46:57.736Z","comments":true,"path":"2022/03/17/vue-property-decorator/index/","link":"","permalink":"/2022/03/17/vue-property-decorator/index/","excerpt":"","text":"vue-property-decoratordata&lt;script lang=&quot;ts&quot;&gt; import {Vue, Component} from &#39;vue-property-decorator&#39;; @Component({}) export default class &quot;组件名&quot; extends Vue{ ValA: string = &quot;hello world&quot;; ValB: number = 1; } &lt;/script&gt; computed&lt;script lang=&quot;ts&quot;&gt; import {Vue, Component} from &#39;vue-property-decorator&#39;; @Component({}) export default class &quot;组件名&quot; extends Vue{ get ValA(){ return 1; } } &lt;/script&gt; Emit@Emit()不传参数,那么它触发的事件名就是它所修饰的函数名.@Emit(name: string),里面传递一个字符串,该字符串为要触发的事件名. &lt;script lang=&quot;ts&quot;&gt; import {Vue, Component, Emit} from &#39;vue-property-decorator&#39;; @Component({}) export default class &quot;组件名&quot; extends Vue{ mounted(){ this.$on(&#39;emit-todo&#39;, function(n) { console.log(n) }) this.emitTodo(&#39;world&#39;); } @Emit() emitTodo(n: string){ console.log(&#39;hello&#39;); } } &lt;/script&gt; Watch&lt;script&gt; import {Vue, Component, Watch} from &#39;vue-property-decorator&#39;; @Watch(&#39;child&#39;) onChangeValue(newVal: string, oldVal: string){ // todo... } @Watch(&#39;person&#39;, {immediate: true, deep: true}) onChangeValue(newVal: Person, oldVal: Person){ // todo... } &lt;/script&gt; Prop&lt;script lang=&quot;ts&quot;&gt; import {Vue, Component, Prop} from &#39;vue-property-decorator&#39;; @Component({}) export default class &quot;组件名&quot; extends Vue{ @Prop(Number) propA!: number; @Prop({default: &#39;default value&#39;}) propB!: string; @propC([String, Boolean]) propC: string | boolean; } &lt;/script&gt; Mixins一种是vue-class-component提供的. &lt;script&gt; import Component {mixins} from &#39;vue-class-component&#39;; import myMixins from &#39;mixins.ts&#39;; @Component // 直接extends myMinxins 也可以正常运行 export class myComponent extends mixins(myMixins) { created(){ console.log(this.value) // =&gt; Hello } } &lt;/script&gt; 第二种方式是在@Component中混入. &lt;script&gt; import { Vue, Component, Prop } from &#39;vue-property-decorator&#39;; import myMixins from &#39;@static/js/mixins&#39;; @Component({ mixins: [myMixins] }) export default class myComponent extends Vue{ created(){ console.log(this.value) // =&gt; Hello } } &lt;/script&gt;","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"vue","slug":"vue","permalink":"/tags/vue/"},{"name":"vue-property-decorator","slug":"vue-property-decorator","permalink":"/tags/vue-property-decorator/"},{"name":"ts","slug":"ts","permalink":"/tags/ts/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"webpack配置全局svg图标","slug":"svg-webpack/index","date":"2022-03-17T07:19:17.000Z","updated":"2022-11-21T06:45:41.770Z","comments":true,"path":"2022/03/17/svg-webpack/index/","link":"","permalink":"/2022/03/17/svg-webpack/index/","excerpt":"","text":"webpack配置const { defineConfig } = require(&#39;@vue/cli-service&#39;) const path = require(&#39;path&#39;) function resolve(dir) { return path.join(__dirname, dir) } const port = 7070; const title = &#39;webpack测试&#39;; module.exports = defineConfig({ transpileDependencies: true, lintOnSave: false, // 是否在开发环境下每次保存代码时都启用 eslint验证 devServer: { port: port }, chainWebpack(config) { config.module.rule(&#39;svg&#39;) .exclude.add(resolve(&#39;src/assets&#39;)) // 添加svg-sprite-loader config.module.rule(&#39;svg-icon&#39;) .test(/\\.svg$/) .include.add(resolve(&#39;src/assets&#39;)) .end() .use(&#39;svg-sprite-loader&#39;) // 添加loader .loader(&#39;svg-sprite-loader&#39;)// 切换上下文到loader .options({symbolId: &#39;icon-[name]&#39;}) .end() } }) icon.vue&lt;template&gt; &lt;div class=&quot;icon&quot;&gt; &lt;svg&gt; &lt;use :xlink:href=&quot;iconName&quot; :class=&quot;svgClass&quot;&gt;&lt;/use&gt; &lt;/svg&gt; &lt;/div&gt; &lt;/template&gt; &lt;script lang=&quot;ts&quot;&gt; import { Component, Vue, Prop } from &#39;vue-property-decorator&#39;; @Component({ components: { }, }) export default class HomeView extends Vue { @Prop() private iconClass!: string; @Prop() private className!: string; get iconName(): string { return `#icon-${this.iconClass}`; } get svgClass(): string { if(this.className) { return `icon-svg ${this.className}`; } return &#39;icon-svg&#39;; } } &lt;/script&gt; &lt;style scoped&gt; .icon-svg { } &lt;/style&gt; icon.jsimport Vue from &quot;vue&quot;; import Icon from &#39;@/components/icon.vue&#39; // 图标自动导入 // 利用webpack 的require.context自动导入 // 返回的req是只去加载svg目录中的模块的函数 const req = require.context(&#39;./svg&#39;, false, /\\.svg$/) // 路径， 是否递归， 匹配规则 req.keys().map(req); Vue.component(&#39;Icon&#39;, Icon) main.js 引用icon.jsimport &#39;@/assets/index&#39; home.vue 使用icon&lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;icon icon-class=&quot;wx&quot;&gt;&lt;/icon&gt; &lt;icon icon-class=&quot;qq&quot;&gt;&lt;/icon&gt; &lt;/div&gt; &lt;/template&gt; &lt;script lang=&quot;ts&quot;&gt; import { Component, Vue } from &#39;vue-property-decorator&#39;; @Component({ components: {} }) export default class HomeView extends Vue {} &lt;/script&gt;","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"/tags/webpack/"},{"name":"svg","slug":"svg","permalink":"/tags/svg/"},{"name":"图标","slug":"图标","permalink":"/tags/图标/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"简单实现vue双向绑定以及v-text、v-model、v-html、@click、插值表达式","slug":"vuejs/index","date":"2022-03-11T08:30:17.000Z","updated":"2022-11-21T06:47:10.941Z","comments":true,"path":"2022/03/11/vuejs/index/","link":"","permalink":"/2022/03/11/vuejs/index/","excerpt":"","text":"html页面&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Vue&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;Untitled-1.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;Compile.js&quot;&gt;&lt;/script&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;{{name}}&lt;/p&gt; &lt;p v-text=&quot;name&quot;&gt;&lt;/p&gt; &lt;p&gt;{{age}}&lt;/p&gt; &lt;input type=&quot;text&quot; v-model=&quot;model&quot;&gt; &lt;div v-html=&quot;html&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; const app = new Vue({ el: &#39;#app&#39;, data: { name: &#39;jina&#39;, // obj: { // age: 18 // }, age: 12, model: &#39;aaa&#39;, html: &#39;&lt;button @click=&quot;click&quot;&gt;这是一个按钮&lt;/button&gt;&#39; }, created() { // setTimeout(() =&gt; { // this.name = &#39;修改测试&#39; // }, 2000); }, metheds: { click() { this.name = &#39;jierui&#39;; console.log(this.name); } } }) // app.name = &#39;zong&#39;; // app.obj.age = 12; // console.log(app.$data); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 实现Vue构造函数class Vue { constructor(options) { // 保存数据 this.$options = options; // 传入data this.$data = options.data; this.$metheds = options.metheds; // 响应化处理 this.observe(this.$data); // Watcher 测试 // new Watcher(this, &#39;name&#39;); // this.name; // new Watcher(this, &#39;obj.age&#39;); // this.obj.age; // 编译器测试 new Compile(options.el, this); if (options.created) { options.created.call(this); } } observe(data) { // 暂不考虑数组和函数 if (!data || typeof data !== &#39;object&#39;) return; Object.keys(data).forEach(key =&gt; { this.defineReactive(data, key, data[key]); // 代理data中的属性到vue根上 this.proxyData(key); }) } defineReactive(data, key, value) { // 递归处理 this.observe(value); // 定义一个Dep const dep = new Dep(); // 给data中的每个key定义拦截 Object.defineProperty(data, key, { get() { // 收集依赖 Dep.target &amp;&amp; dep.addDep(Dep.target); return value; }, set(newValue) { if (newValue !== value) { value = newValue; console.log(key + &#39; 数据更新！&#39;) dep.notify(); } } }) } proxyData(key) { Object.defineProperty(this, key, { get() { return this.$data[key]; }, set(newValue) { this.$data[key] = newValue; } }) } } // 创建dep 管理所有watcher class Dep { constructor() { // 存储所有依赖 this.watchers = []; } addDep(watcher) { this.watchers.push(watcher); } notify() { this.watchers.forEach(watcher =&gt; watcher.update()) } } // 创建watcher 保存data中数值和页面中的挂钩关系 class Watcher { constructor(vm, key, cb) { this.vm= vm; this.key = key; this.cb = cb; // 创建实例时 立刻将该实例指向静态属性Dep.target便于依赖收集 Dep.target = this; this.vm[key]; Dep.target = null; } update() { console.log(this.key + &#39;更新了！&#39;); this.cb.call(this.vm, this.vm[this.key]); } } 实现Compile构造函数// 遍历dom结构，解析指令和插值表达式 class Compile { // el: 待编译模板 vm: Vue实例 constructor(el, vm) { this.$el = document.querySelector(el); this.$vm = vm; // 把模板中的内容移到片段操作 this.$fragment = this.nodeFragment(this.$el); // 执行编译器 this.compile(this.$fragment); // 放回$el中 this.$el.appendChild(this.$fragment); } nodeFragment(el) { /* DocumentFragments 是DOM节点。它们不是主DOM树的一部分。 通常的用例是创建文档片段，将元素附加到文档片段，然后将文档片段附加到DOM树。 在DOM树中，文档片段被其所有的子元素所代替。 因为文档片段存在于内存中，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面回流（对元素位置和几何上的计算）。 因此，使用文档片段通常会带来更好的 性能 */ const fragment = document.createDocumentFragment(); let child; while (child = el.firstChild) { fragment.appendChild(child); } return fragment; } compile(el) { const childNodes = el.childNodes; Array.from(childNodes).forEach(node =&gt; { if (node.nodeType === 1) { // 元素 console.log(&#39;编译元素&#39; + node.nodeName); this.compileElement(node); } else if (this.isInter(node)) { // 文本 console.log(&#39;编译插值文本&#39; + node.textContent); this.compileText(node); } // 递归子节点 if (node.children &amp;&amp; node.childNodes.length &gt; 0) { this.compile(node); } }) } // 正则表达式解析是否为文本 isInter(node) { return node.nodeType === 3 &amp;&amp; /\\{\\{(.*)\\}\\}/.test(node.textContent) } // 文本编译 compileText(node) { const exp = RegExp.$1; this.update(node, exp, &#39;text&#39;); node.textContent = this.$vm[RegExp.$1]; } // 元素编译 compileElement(node) { const nodeAttrs = node.attributes; Array.from(nodeAttrs).forEach(attr =&gt; { // v-xxx=&quot;yyy&quot; const attrName = attr.name;// v-xxx const exp = attr.value;// yyy if (attrName.indexOf(&#39;v-&#39;) === 0) { const dir = attrName.substring(2); this[dir] &amp;&amp; this[dir](node, exp, dir); } else if (attrName === &#39;@click&#39;) { const _this = this; node.addEventListener(&#39;click&#39;, function() { _this.$vm.$metheds[exp].call(_this.$vm); }) } }) } // 更新 update(node, exp, dir) { const updator = this[dir + &#39;Updator&#39;]; updator &amp;&amp; updator(node, this.$vm[exp]); new Watcher(this.$vm, exp, function(value) { updator &amp;&amp; updator(node, value); }); } // v-text 更新处理 text(node, exp, dir) { this.update(node, exp, dir) } // 修改文本的值 textUpdator(node, value) { node.textContent = value; } // v-html html(node, exp, dir) { this.update(node, exp, dir) } htmlUpdator(node, value) { node.innerHTML = value; } // v-model model(node, exp, dir) { this.update(node, exp, dir); const _this = this; node.addEventListener(&#39;input&#39;, function(InputEvent) { _this.$vm[exp] = InputEvent.target.value; }) } modelUpdator(node, value) { node.value = value; } }","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"原理","slug":"原理","permalink":"/tags/原理/"},{"name":"vue","slug":"vue","permalink":"/tags/vue/"},{"name":"双向绑定","slug":"双向绑定","permalink":"/tags/双向绑定/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"手写notice弹窗组件","slug":"notice-component/index","date":"2022-02-25T09:56:17.000Z","updated":"2022-11-21T06:45:09.372Z","comments":true,"path":"2022/02/25/notice-component/index/","link":"","permalink":"/2022/02/25/notice-component/index/","excerpt":"","text":"手写notice弹窗组件notice.vue &lt;template&gt; &lt;div v-if=&quot;isShow&quot;&gt; &lt;p&gt;{{title}}&lt;/p&gt; &lt;p&gt;{{text}}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: { title: { type: String, default: &#39;&#39; }, text: { type: String, default: &#39;&#39; }, time: { type: Number, default: 0 } }, data() { return { isShow: false } }, methods: { show() { this.isShow = true; this.time &amp;&amp; setTimeout(() =&gt; { this.hide(); }, this.time) }, hide() { this.isShow = false; this.remove(); } } } &lt;/script&gt; create.js import Vue from &quot;vue&quot;; export default function create(component, props) { // 创建vue实例 const vm = new Vue({ render(h) { return h(component, {props}) } }).$mount(); // 获取组件实例 const comp = vm.$children[0]; // 组件实例追加到body document.body.appendChild(vm.$el); // 清理函数 comp.remove = () =&gt; { document.body.removeChild(vm.$el); vm.$destroy(); } // 返回组件实例 return comp; } 使用notice组件 const notice = Create(Notice, { title: &#39;登录&#39;, text: &#39;正确！&#39;, time: 3000 }) notice.show();","categories":[{"name":"notice弹窗组件","slug":"notice弹窗组件","permalink":"/categories/notice弹窗组件/"}],"tags":[{"name":"组件","slug":"组件","permalink":"/tags/组件/"},{"name":"notice","slug":"notice","permalink":"/tags/notice/"},{"name":"弹窗","slug":"弹窗","permalink":"/tags/弹窗/"}],"keywords":[{"name":"notice弹窗组件","slug":"notice弹窗组件","permalink":"/categories/notice弹窗组件/"}]},{"title":"手写form组件","slug":"form-component/index","date":"2022-02-25T06:04:17.000Z","updated":"2022-11-21T06:44:22.926Z","comments":true,"path":"2022/02/25/form-component/index/","link":"","permalink":"/2022/02/25/form-component/index/","excerpt":"","text":"form组件input组件 &lt;template&gt; &lt;div&gt; &lt;input :value=&quot;value&quot; @input=&quot;onInput&quot; v-bind=&quot;$attrs&quot;&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { inheritAttrs: false, props: { value: { type: String, default: &#39;&#39; } }, methods: { onInput(e) { this.$emit(&#39;input&#39;, e.target.value); // 防止input多层嵌套，formItem无法正常派发事件 const parent = this.getParent(this.$parent); parent.$emit(&#39;validate&#39;); }, getParent(parent) { if (parent.$options._componentTag === &#39;CFormItem&#39;) return parent; this.getParent(parent.$parent); } } } &lt;/script&gt; checkbox组件 &lt;template&gt; &lt;div&gt; &lt;input type=&quot;checkbox&quot; :checked=&quot;checked&quot; @change=&quot;onCahnge&quot; v-bind=&quot;$attrs&quot;&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { inheritAttrs: false, props: { checked: { type: Boolean, default: false } }, model: { prop: &#39;checked&#39;, event: &#39;change&#39; }, methods: { onCahnge(e) { this.$emit(&#39;change&#39;, e.target.checked); const parent = this.getParent(this.$parent); parent.$emit(&#39;validate&#39;); }, getParent(parent) { if (parent.$options._componentTag === &#39;CFormItem&#39;) return parent; this.getParent(parent.$parent); } } } &lt;/script&gt; formItem组件 &lt;template&gt; &lt;div&gt; &lt;label v-if=&quot;label&quot;&gt; {{ label }} &lt;/label&gt; &lt;slot&gt;&lt;/slot&gt; &lt;p v-if=&quot;erroeMsg&quot;&gt;{{ erroeMsg }}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; /* 表单异步验证js库：async-validator，element-ui中的form组件所使用的验证方式。 npm install --save async-validator */ import Schema from &#39;async-validator&#39;; export default { props: { label: { type: String, default: &#39;&#39; }, prop: { type: String } }, inject: [&#39;form&#39;], data() { return { erroeMsg: &#39;&#39; } }, mounted() { this.$on(&#39;validate&#39;, () =&gt; { this.validate(); }) }, methods: { validate() { // 获取校验规则 const rule = this.form.rules[this.prop]; // 获取数值 const value = this.form.model[this.prop]; // 执行校验 const desc = { [this.prop]: rule }; const schema = new Schema(desc); return schema.validate({[this.prop]: value}, errors =&gt; { if (errors) { this.erroeMsg = errors[0].message; } else { this.erroeMsg = &#39;&#39;; } }); } } } &lt;/script&gt; form组件 &lt;template&gt; &lt;div&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: { model: { type: Object, requireg: true }, rules: { type: Object } }, provide() { return { form : this } }, data() { return { } }, methods: { validate(cb) { const tasks = this.$children .filter(item =&gt; item.prop) .map(item =&gt; item.validate()); Promise.all(tasks) .then(() =&gt; cb(true)) .catch(() =&gt; cb(false)) } } } &lt;/script&gt; 引用form组件 &lt;template&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;CForm :model=&quot;model&quot; :rules=&quot;rules&quot; ref=&quot;form&quot;&gt; &lt;CFormItem label=&quot;用户名&quot; prop=&quot;userName&quot;&gt; &lt;CInput v-model=&quot;model.userName&quot;&gt;&lt;/CInput&gt; &lt;/CFormItem&gt; &lt;CFormItem label=&quot;密码&quot; prop=&quot;passWord&quot;&gt; &lt;CInput v-model=&quot;model.passWord&quot; type=&quot;passWord&quot;&gt;&lt;/CInput&gt; &lt;/CFormItem&gt; &lt;CFormItem label=&quot;勾选&quot; prop=&quot;checked&quot;&gt; &lt;CCheckBox v-model=&quot;model.checked&quot;&gt;&lt;/CCheckBox&gt; &lt;/CFormItem&gt; &lt;CFormItem&gt; &lt;button @click=&quot;login&quot;&gt;登录&lt;/button&gt; &lt;/CFormItem&gt; {{ model }} &lt;/CForm&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import CForm from &#39;@/components/form/index&#39;; import CInput from &#39;@/components/form/input.vue&#39; import CCheckBox from &#39;@/components/form/checkBox&#39; import CFormItem from &#39;@/components/form/formItem.vue&#39; export default { components: { CForm, CInput, CFormItem, CCheckBox }, data() { return { model: { userName: &#39;&#39;, passWord: &#39;&#39;, checked: false }, rules: { userName: [{required: true, message: &quot;请输入用户名&quot;}], passWord: [{required: true, message: &quot;请输入密码&quot;}], checked: [{validator: (rule, value) =&gt; value, message: &quot;请勾选&quot;}] } } }, methods: { login() { this.$refs.form.validate((isValid) =&gt; { if (isValid) { alert(&#39;登录！&#39;) } else { alert(&#39;错误！&#39;) } }) } }, created() { // console.log(&#39;路由查询参数&#39;,this.$tab.query()) }, } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt;","categories":[{"name":"form","slug":"form","permalink":"/categories/form/"}],"tags":[{"name":"form","slug":"form","permalink":"/tags/form/"},{"name":"组件","slug":"组件","permalink":"/tags/组件/"},{"name":"表单验证","slug":"表单验证","permalink":"/tags/表单验证/"}],"keywords":[{"name":"form","slug":"form","permalink":"/categories/form/"}]},{"title":"笔记","slug":"note/index","date":"2022-02-23T06:58:17.000Z","updated":"2022-11-21T06:44:59.831Z","comments":true,"path":"2022/02/23/note/index/","link":"","permalink":"/2022/02/23/note/index/","excerpt":"","text":"组件通信父 =&gt; 子 props // child props: { msg: String } // parent &lt;helloWorld msg=&quot;welcome&quot; /&gt; $refs // parent &lt;helloWorld msg=&quot;welcome&quot; ref=&quot;helloWorld&quot; /&gt; this.$refs.helloWorld.xx = &#39;xxx&#39; $children // parent $children不保证子组件顺序 this.$children[0].xx = &#39;xxx&#39; 子 =&gt; 父 $emit // child this.$emit(&#39;add&#39;, &#39;msg&#39;) // parent &lt;helloWorld @add=&quot;add&quot; /&gt; 兄弟组件通信 $parent / $root // brother1 监听 this.$parent.$on(&#39;foo&#39;, &#39;msg&#39;) // brother1 派发 this.$parent.$emit(&#39;foo&#39;) 祖先后代组件通信注：官方不建议项目使用，并且不建议修改 // 祖 provide() { return { foo: &#39;foo&#39; } } // 后 inject: [&#39;foo&#39;] 任意两个组件通信Vue.prototype.$bus = new Vue() // child1 this.$bus.$on(&#39;foo&#39;, handle) // child2 this.$bus.$emit(&#39;foo&#39;, &#39;msg&#39;) 插槽// 匿名插槽 &lt;div&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;helloWorld&gt; &lt;template v-slot:default&gt;&lt;/template&gt; &lt;/helloWorld&gt; // 具名插槽 &lt;div&gt; &lt;slot name=&quot;main&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;helloWorld&gt; &lt;template v-slot:main&gt;&lt;/template&gt; &lt;/helloWorld&gt; // 作用域插槽 &lt;div&gt; &lt;slot name=&quot;main&quot; msg=&quot;msg&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;helloWorld&gt; &lt;template v-slot:main={msg}&gt;{{ msg }}&lt;/template&gt; &lt;/helloWorld&gt;","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"/tags/笔记/"},{"name":"vue","slug":"vue","permalink":"/tags/vue/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"数组遍历的实现","slug":"array-traverse-rewrite/index","date":"2022-02-23T02:18:17.000Z","updated":"2022-11-21T06:43:15.168Z","comments":true,"path":"2022/02/23/array-traverse-rewrite/index/","link":"","permalink":"/2022/02/23/array-traverse-rewrite/index/","excerpt":"","text":"实现数组的filter方法Array.prototype.filter =&gt; (fn) { let arr = []; for (let i = 0; i &lt; this.lenght; i++) { if (fn(this[i], i, this)) { arr.push(this[i]) } } return arr; }","categories":[{"name":"JS","slug":"JS","permalink":"/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"/tags/JS/"},{"name":"Array","slug":"Array","permalink":"/tags/Array/"},{"name":"遍历","slug":"遍历","permalink":"/tags/遍历/"}],"keywords":[{"name":"JS","slug":"JS","permalink":"/categories/JS/"}]},{"title":"Axios拦截请求封装","slug":"axios/index","date":"2022-02-22T06:57:17.000Z","updated":"2022-11-21T06:43:30.017Z","comments":true,"path":"2022/02/22/axios/index/","link":"","permalink":"/2022/02/22/axios/index/","excerpt":"","text":"Axios拦截请求封装请求封装 import { ApiError } from &#39;@/structure/Request&#39;; import { Config } from &#39;@/utils/Config&#39;; import axios, { AxiosRequestConfig } from &#39;axios&#39;; const service = axios.create({ baseURL: Config.API_ADDRESS, timeout: Config.TIME_OUT }); // 请求拦截器 service.interceptors.request.use( (config: AxiosRequestConfig) =&gt; { config.headers[&#39;token&#39;] = Config.getToken() || &#39;&#39;; return config; }, error =&gt; { Promise.reject(error); } ); // 响应拦截器 service.interceptors.response.use( response =&gt; { const data = response.data; if (data.code !== 200) { switch (data.code) { case 400: return Promise.reject(ApiError.BadRequest); case 401: return Promise.reject(ApiError.Unauthorized); case 403: return Promise.reject(ApiError.Forbidden); case 404: return Promise.reject(ApiError.ResourceNotFound); case 500: return Promise.reject(ApiError.ServerSideError); case 1001: return Promise.reject(ApiError.CustomError.from(data.msg)); default: return Promise.reject(ApiError.Unexpected.from(data.msg)); } } else { return data; } }, error =&gt; { return Promise.reject(error); } ); export default service; 调用封装 import { ApiResponse } from &#39;@/structure/Request&#39;; import service from &#39;@/utils/service&#39;; export class CommonApi { public static async getTimestamp(): Promise&lt;number&gt; { const response = await service.get&lt;void, ApiResponse&lt;number&gt;&gt;(&#39;/utils/getSystemTime&#39;); return response.result; } }","categories":[{"name":"Axios","slug":"Axios","permalink":"/categories/Axios/"}],"tags":[{"name":"Axios","slug":"Axios","permalink":"/tags/Axios/"},{"name":"Axios拦截","slug":"Axios拦截","permalink":"/tags/Axios拦截/"}],"keywords":[{"name":"Axios","slug":"Axios","permalink":"/categories/Axios/"}]},{"title":"vue异步更新机制","slug":"vue-asynchronous-update-mechanism/index","date":"2022-02-21T02:16:17.000Z","updated":"2022-11-21T06:46:23.685Z","comments":true,"path":"2022/02/21/vue-asynchronous-update-mechanism/index/","link":"","permalink":"/2022/02/21/vue-asynchronous-update-mechanism/index/","excerpt":"","text":"vue异步更新机制vue中更新dom是异步执行的，只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。（先缓冲，缓冲后再将多次触发属性的最后一次作为promise放入队列；而不是一上来就放队列） vue中数据的更新到dom是异步的，数据的异步更新可以理解成一个promise的微任务；并且对同一个属性值进行多次赋值时，只有最后一次赋值会作为一个promise微任务放到更新队列。 &lt;template&gt; &lt;div id=&quot;example&quot;&gt;{{message}}&lt;/div&gt; &lt;/template&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#example&#39;, data: { message: &#39;123&#39; } }) Promise.resolve(1).then(value =&gt; { console.log(&quot;xxx&quot;, vm.$el.textContent); // 第二步输出：123 }) vm.message = &#39;msg&#39; // 更改数据 Promise.resolve(2).then(value =&gt; { console.log(&quot;测试&quot;, vm.$el.textContent); // 第三步输出：new }) vm.message = &#39;new&#39; // 更改数据 Promise.resolve(3).then(value =&gt; { console.log(&quot;fff&quot;, vm.$el.textContent); // 第四步输出：new }) console.log(vm.$el.textContent); // 第一步输出：123 &lt;/script&gt;","categories":[{"name":"VUE","slug":"VUE","permalink":"/categories/VUE/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"/tags/VUE/"},{"name":"异步更新机制","slug":"异步更新机制","permalink":"/tags/异步更新机制/"}],"keywords":[{"name":"VUE","slug":"VUE","permalink":"/categories/VUE/"}]},{"title":"前端 JS 编程题（应用类）","slug":"js-application/index","date":"2021-11-16T03:30:45.000Z","updated":"2022-11-21T06:44:43.150Z","comments":true,"path":"2021/11/16/js-application/index/","link":"","permalink":"/2021/11/16/js-application/index/","excerpt":"","text":"一、手写防抖（debounce）// debounce // 举例：购物车加减数量 function debounce(fn, delay=500) { // timer 写在闭包中，因此防抖也是闭包的一个应用 let timer = null; return function() { if (timer) { clearTimeout(timer) } timer = setTimeout(() =&gt; { fn.apply(this, arguments); timer = null; }, delay) } } // 验证 input1.addEventListener(&#39;keyup&#39;, debounce(() =&gt; { console.log(input1.value); }), 600) 二、手写节流（throttle）// 节流 // 举例：button按钮点击后置灰 function throttle(fn, delay=100) { let timer = null; return () =&gt; { if (timer) return; timer = setTimeOut(() =&gt; { fn.apply(this, arguments); timer = null; }, delay) } } // 验证 div1.addEventListener((&#39;drag&#39;, throttle(function (e) { console.log(e.offsetX, e.offsetY) }))) 三、事件委托假设一个 ul 下有一万个 li，li 的 innerHTML 是从 0 到 9999，当点击某个 li 时输出该 li 代表的值 window.onload = function() { // 创建dom var ul = document.getElementsByTagName(&quot;ul&quot;); var arr = []; for (let i = 0; i &lt; 100000; i++) { arr.push(i); } ul[0].innerHTML = &#39;&lt;li&gt;&#39; + arr.join(&#39;&lt;/li&gt;&lt;li&gt;&#39;) + &#39;&lt;/li&gt;&#39; // 事件委托 let ul = document.getElementById(&#39;ul&#39;); ul.onclick = (e) =&gt; { console.log(e.target.innerText) } } 四、手写 Promise 加载一张图片function loadImg(scr) { return new Promise((resolve, reject) =&gt; { const img = document.createElement(&#39;img&#39;); img.onload = () =&gt; { resolve(img); } img.onerror = () =&gt; { reject(new Error(`图片加载失败 ${src}`)) } img.src = src; }) } const url = &#39;https://pic.leetcode-cn.com/1604237471-xbJgZl-%E5%9B%BE%E7%89%871.png&#39;; loadImg(url).then(img =&gt; { console.log(img.width) return img }).then(img =&gt; { console.log(img.height) }).catch(ex =&gt; console.error(ex)) 五、用 ajaxajax 原生实现一个 post 请求function ajax_post(url, data) { // 1. 异步对象 ajax var ajax = new XMLHttpRequest(); // 2. url 方法 ajax.open(&#39;post&#39;, url); // 3. 设置请求报文 ajax.setRequestHeader(&#39;Content-type&#39;, &#39;text/plain&#39;); // 4. 发送 if (data) { ajax.send(data); } else { ajax.send(); } // 5. 注册事件 ajax.onreadystatechange = function () { if (ajax.readyState === 4 &amp;&amp; ajax.status === 200) { console.log(ajax.respenseText); } } } 六、每隔一秒输出一个数字// 使用let for (let i = 0; i &lt; 10; i++) { setTimeout(() =&gt; { console.log(i); }, 1000 * i) } // 使用闭包 for (var i = 0; i &lt; 10; i++) { (function(j) { setTimeout(() =&gt; { console.log(j); }, 1000 * j) })(i) } // 使用settimeout第三个参数 for(var i = 0; i &lt;= 5; i++){ setTimeout((j) =&gt; { console.log(j); },i * 1000, i) } 七、 判断两个对象是否相等/* * @param x {Object} 对象1 * @param y {Object} 对象2 * @return {Boolean} true 为相等，false 为不等 */ const deepEqual = (x, y) =&gt; { if (x === y) { return true; } else if ((typeof x === &#39;object&#39; &amp;&amp; x != null) &amp;&amp; (typeof y === &#39;object&#39; &amp;&amp; y != null)) { if (Object.keys(x).length !=== Object.keys(y).length) return false; for (let prop in x) { if (y.hasOwnproperty(prop)) { if (!deepEqual(x.prop, y.prop)) return false; } else { return false; } } return true; } return false; } // 调库实现 console.log(_.isEqual(x, y))","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"},{"name":"前端","slug":"笔记/前端","permalink":"/categories/笔记/前端/"}],"tags":[{"name":"JS","slug":"JS","permalink":"/tags/JS/"},{"name":"前端","slug":"前端","permalink":"/tags/前端/"},{"name":"应用","slug":"应用","permalink":"/tags/应用/"},{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"},{"name":"前端","slug":"笔记/前端","permalink":"/categories/笔记/前端/"}]},{"title":"前端 JS 编程题（原理类）","slug":"js-principle/index","date":"2021-11-14T08:42:45.000Z","updated":"2022-11-21T06:44:51.509Z","comments":true,"path":"2021/11/14/js-principle/index/","link":"","permalink":"/2021/11/14/js-principle/index/","excerpt":"","text":"一、 深拷贝// deepClone function deepClone(obj = {}) { if (typeof obj !== &#39;object&#39; || obj == null) { // obj 是 null 或者不是对象和数组，直接返回 return obj; } let res; if (obj instanceof Array) { res = []; } else { res = {}; } for (let key in obj) { // 判断自身中是否包含自身属性 if (obj.hasOwnProperty(key)) { res[key] = deepClone(obj[key]) } } return res; } // 验证 o = {a: 1, d: {c: &#39;4&#39;}}; res = deepClone(o); console.log(res); console.log(res == o); 二、浅拷贝// 首先定义一个对象 const hero = { name: &#39;Batman&#39;, city: &#39;Gotham&#39; }; // **********************方法一********************** const heroEnhancedClone = { ...hero, name: &#39;Batman Clone&#39;, realName: &#39;Bruce Wayne&#39; }; // 验证 // { name: &#39;Batman Clone&#39;, city: &#39;Gotham&#39;, realName: &#39;Bruce Wayne&#39; } heroEnhancedClone; // **********************方法二********************** const { ...heroClone } = hero; // 验证 heroClone; // { name: &#39;Batman&#39;, city: &#39;Gotham&#39; } hero === heroClone; // =&gt; false // **********************方法三********************** const hero = { name: &#39;Batman&#39;, city: &#39;Gotham&#39; }; // 验证 const heroClone = Object.assign({}, hero); heroClone; // { name: &#39;Batman&#39;, city: &#39;Gotham&#39; } hero === heroClone; // =&gt; false 三、手写 bind 函数// 模拟 bind Function.prototype.bind1 = function() { // 将参数拆解为数组 const args = Array.prototype.slice.call(arguments) // 变成数组 // 获取 this（数组第一项） const t = args.shift() // fn1.bind(...) 中的 fn1 const self = this // 返回一个函数 return function() { return self.apply(t, args) } } function fn1(a, b, c){ console.log(&#39;this&#39;, this) console.log(a, b, c) return &#39;this is fn1&#39; } const fn2 = fn1.bind1({x: 100}, 10, 20, 30) const res = fn2() console.log(res) 四、手写 newfunction funcNew(obj, ...args) { const newObj = Object.create(obj.prototype); const result = obj.apply(newObj, args); return (typeof result === &#39;object&#39; &amp;&amp; result !== null) ? result : newObj; } new 一个实例会受到返回值的影响，比如： /** * --- Person 中 return 一个对象，p 为该对象 --- */ function Person(name) { this.name = name; return {age: 35} } Person.prototype.sayName = function() { console.log(this.name); } const p = new Person(&#39;orange&#39;) console.log(p) // { age: 35 } console.log(p.name) // undefined p.sayName(); // TypeError: p.sayName is not a function /** * --- Person 返回非对象，return 不影响结果 --- */ function Person(name) { this.name = name; return &#39;free&#39; } Person.prototype.sayName = function() { console.log(this.name); } const p = new Person(&#39;orange&#39;) console.log(p) // Person { name: &#39;orange&#39; } console.log(p.name) // orange p.sayName(); // orange 五、手写 instanceof/* * --- 手动实现 instanceof --- */ function newInstanceOf (leftValue, rightValue) { if (typeof leftValue !== &#39;object&#39; || rightValue == null) { return false; } let rightProto = rightValue.prototype; leftValue = leftValue.__proto__; while (true) { if (leftValue === null) return false; if (leftValue === rightProto) return true; leftValue = leftValue.__proto__; } } /* * --- 验证 --- */ const a = []; const b = {}; function Foo () {} var c = new Foo() function Child () {} function Father() {} Child.prototype = new Father() var d = new Child() console.log(newInstanceOf(a, Array)) // true console.log(newInstanceOf(b, Object)) // true console.log(newInstanceOf(b, Array)) // false console.log(newInstanceOf(a, Object)) // true console.log(newInstanceOf(c, Foo)) // true console.log(newInstanceOf(d, Child)) // true console.log(newInstanceOf(d, Father)) // true console.log(newInstanceOf(123, Object)) // false console.log(123 instanceof Object) // false 这个问题既考察了 instanceof 的原理，又考察了原型链，还考察了代码能力，是一个好问题。在实现代码中，我们判断 leftValue 是否为 rightValue 的实例，思想是在 leftValue 的原型链上，即 leftValue.proto 上寻找是否存在 rightValue.prototype。 六、实现 Promise.all()1、接收一个 Promise 实例的数组或具有 Iterator 接口的对象， 2、如果元素不是 Promise 对象，则使用 Promise.resolve 转成 Promise 对象 3、如果全部成功，状态变为 resolved，返回值将组成一个数组传给回调 4、只要有一个失败，状态就变为 rejected，返回值将直接传递给回调all() 的返回值也是新的 Promise 对象 function promiseAll(promises) { return new Promise(function(resolve, reject) { if (!isArray(promises)) { return reject(new TypeError(&#39;arguments must be an array&#39;)); } var resolvedCounter = 0; var promiseNum = promises.length; var resolvedValues = new Array(promiseNum); for (var i = 0; i &lt; promiseNum; i++) { (function(i) { Promise.resolve(promises[i]).then(function(value) { resolvedCounter++ resolvedValues[i] = value if (resolvedCounter == promiseNum) { return resolve(resolvedValues) } }, function(reason) { return reject(reason) }) })(i) } }) }","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"},{"name":"前端","slug":"笔记/前端","permalink":"/categories/笔记/前端/"}],"tags":[{"name":"JS","slug":"JS","permalink":"/tags/JS/"},{"name":"前端","slug":"前端","permalink":"/tags/前端/"},{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"},{"name":"原理","slug":"原理","permalink":"/tags/原理/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"},{"name":"前端","slug":"笔记/前端","permalink":"/categories/笔记/前端/"}]},{"title":"前端 JS 编程题（算法类）","slug":"js-algorithm/index","date":"2021-11-14T06:42:45.000Z","updated":"2022-11-21T06:44:34.998Z","comments":true,"path":"2021/11/14/js-algorithm/index/","link":"","permalink":"/2021/11/14/js-algorithm/index/","excerpt":"","text":"一、手写快排、冒泡、选择排序① 快速排序/** * --- 测试用例 --- * * 输入：[1, 34, 5, 76, 8, 6, 9, 7, 6, 3] * 输出：[1, 3, 5, 6, 6, 7, 8, 9, 34, 76] * * --- 说明 --- * * 思考：快速排序是稳定的吗？ * 解答：base 的每次选择，会导致快排是不稳定排序。 */ const quickSort = (nums) =&gt; { if (nums.length &lt; 2) { return nums; } else { var left = []; var right = []; var pivot = Math.floor(nums.length / 2); // Math.floor 向下取整 var base = nums.splice(pivot, 1)[0]; for (let i = 0; i &lt; nums.length; i++) { if (nums[i] &lt; base) { left.push(nums[i]); } else { right.push(nums[i]); } } } return quickSort(left).concat([base], quickSort(right)); } ② 冒泡排序/** * --- 测试用例 --- * * 输入：[5, 2, 4, 7, 9, 8, 3, 6, 3, 8, 3] * 输出：[2, 3, 3, 3, 4, 5, 6, 7, 8, 8, 9] * * --- 说明 --- * * 思考：冒泡排序是稳定的吗？ * 解答：稳定。相等的元素不发生交换 */ const bubbleSort = (nums) =&gt; { for (var i = 0; i &lt; nums.length - 1; i++) { for (var j = 0; j &lt; nums.length - 1 - i; j++) { if (nums[j] &gt; nums[j + 1]) { let tmp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = tmp; } } } return nums; } ③ 选择排序/** * --- 测试用例 --- * * 输入：[6, 45, 3, 2, 5, 6, 8, 4, 3, 4, 56, 67, 5] * 输出：[2, 3, 3, 4, 4, 5, 5, 6, 6, 8, 45, 56, 67] * * --- 说明 --- * * 思考：选择排序是稳定的吗？ * 解答：要看代码是如何实现的，在本例中由于有交换，所以是不稳定排序。 */ const selectSort = (nums) =&gt; { var idx; // 最小值的索引 for (var i = 0; i &lt; nums.length - 1; i++) { idx = i; for (var j = i + 1; j &lt; nums.length; j++) { if (nums[j] &lt; nums[idx]) { idx = j; } } if (nums[i] &gt; nums[idx]) { let tmp = nums[idx]; nums[idx] = nums[i]; nums[i] = tmp; } } return nums; }s 二、URL 拆解问题①/** * --- 题目描述 --- * * 实现一个函数，可以对 url 中的 query 部分做拆解，返回一个 key: value 形式的 object * * --- 实例 --- * * 输入：&#39;http://sample.com/?a=1&amp;e&amp;b=2&amp;c=xx&amp;d#hash&#39; * 输出：{a: 1, b: 2, c: &#39;xx&#39;, d: &#39;&#39;} */ function getQueryObj(url) { // TODO let arr = url.split(&#39;?&#39;)[1].split(&#39;#&#39;)[0].split(&#39;&amp;&#39;); const res = {}; arr.forEach(e =&gt; { const [key, value] = e.split(&#39;=&#39;); if (!value) { res[key] = &#39;&#39;; } else { res[key] = value; } }) return res; } ②/** * --- 题目描述 --- * * 实现一个 parseParem 函数，将 url 转化为指定结果 * * --- 测试用例 --- * * 输入：url = &#39;http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled&#39; * 输出： { user:&#39;anonymous&#39;, id:[123,456],// 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型 city:&#39;北京&#39;,// 中文需解码 enabled: true // 未指定值的 key 与约定为 true } */ const parseParem = (url) =&gt; { const arr = url.split(&#39;?&#39;)[1].split(&#39;&amp;&#39;); const res = {}; arr.forEach((e) =&gt; { let key = e.split(&#39;=&#39;)[0], value = e.split(&#39;=&#39;)[1]; if (value === undefined) { res[key] = true; } else { if (key in res) { Array.isArray(res[key]) ? res[key].push(value) : res[key] = [res[key]].concat(value); } else { res[key] = decodeURI(value) } } }) return res; } 三、将 HTTP header 转换成 js 对象/** * --- 题目描述 --- * * 实现一个方法，把 HTTP 文本形式(字符串)的 header 转换成 JS 对象。 * * --- 测试用例 --- * * 输入： * `Accept-Ranges: bytes * Cache-Control: max-age=6000, public * Connection: keep-alive * Content-Type: application/javascript` * 输出： * { * &quot;Accept-Ranges&quot;: &quot;bytes&quot;, * &quot;Cache-Control&quot;: &quot;max-age=6000, public&quot;, * Connection: &quot;keep-alive&quot;, * &quot;Content-Type&quot;: &quot;application/javascript&quot; * } * * --- 解题思路 --- * * 1. 首先将每行数据作为数组的一个元素 * 2. 将每个元素使用冒号分割，前面为 `key`，后面为 `value`。 */ const solution = (s) =&gt; { let res = {}; let arr = s.split(&quot;\\n&quot;); arr.forEach((e) =&gt; { let tmp = e.split(&quot;: &quot;); res[tmp[0]] = tmp[1]; }) return res; } 四、数组扁平化① 递归var arr = [1, [2, [3, 4]]]; function flatten(arr) { var result = []; for (var i = 0, len = arr.length; i &lt; len; i++) { if (Array.isArray(arr[i])) { result = result.concat(flatten(arr[i])) } else { result.push(arr[i]) } } return result; } console.log(flatten(arr)) ② es6 拓展运算符var arr = [1, [2, [3, 4]]]; function flatten(arr) { while (arr.some(item =&gt; Array.isArray(item))) { arr = [].concat(...arr); } return arr; } console.log(flatten(arr)) ③ flatconst arr1 = [0, 1, 2, [[[3, 4]]]]; console.log(arr1.flat(3)); // 3 代表数组内最多嵌套层数 // output: [0, 1, 2, 3, 4]","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"},{"name":"前端","slug":"笔记/前端","permalink":"/categories/笔记/前端/"}],"tags":[{"name":"JS","slug":"JS","permalink":"/tags/JS/"},{"name":"前端","slug":"前端","permalink":"/tags/前端/"},{"name":"面试题","slug":"面试题","permalink":"/tags/面试题/"},{"name":"算法","slug":"算法","permalink":"/tags/算法/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"},{"name":"前端","slug":"笔记/前端","permalink":"/categories/笔记/前端/"}]},{"title":"Git与Github进行SSH连接","slug":"git-github-ssh/index","date":"2020-04-14T08:43:17.000Z","updated":"2022-11-21T06:44:28.800Z","comments":true,"path":"2020/04/14/git-github-ssh/index/","link":"","permalink":"/2020/04/14/git-github-ssh/index/","excerpt":"","text":"安装Git1、到Git官网下载与你正在使用的操作系统(本文以windows为例)相对应的文件。一般地，选择64-bit Git for Windows Setup2、安装时注意：勾选添加git到环境变量；在Windows Explorer Integration中勾选Git Bash Here。其余配置默认即可3、安装完成后(可能需要注销或重启)，在任意一个文件夹空白处右键，检查是否有Git Bash Here的选项 设置邮箱和用户名打开Git Bash，输入命令均在Git Bash中进行 git config --global user.name &quot;WangRongsheng&quot; git config --global user.email &quot;603329354@qq.com&quot; 设置邮箱和用户名ssh-keygen -t rsa -C &quot;603329354@qq.com&quot; 回车之后会出现如下所示的输出，直接按回车即可： Generating public/private rsa key pair. Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa): (按回车键) Enter passphrase (empty for no passphrase): (按回车键) Enter same passphrase again: (按回车键) 将公钥添加到github中1、在C:\\user\\xxx.ssh\\文件夹中找到id_rsa.pub这个文件，用文本编辑器(如记事本)打开，复制里面的所有内容2、登陆github账号，点击头像旁的小三角展开，点击settings-SSH and GPG keys-New SSH key，在Title中取一个名字（任意），key中粘贴你刚刚复制的内容。然后点击Add SSH key即可 测试是否关联成功输入： ssh -T git@github.com 出现以下结果即为成功： Hi WangRongsheng! You&#39;ve successfully authenticated, but GitHub does not provide shell access.","categories":[{"name":"git","slug":"git","permalink":"/categories/git/"},{"name":"github","slug":"git/github","permalink":"/categories/git/github/"},{"name":"ssh","slug":"git/github/ssh","permalink":"/categories/git/github/ssh/"}],"tags":[{"name":"git","slug":"git","permalink":"/tags/git/"},{"name":"github","slug":"github","permalink":"/tags/github/"},{"name":"ssh","slug":"ssh","permalink":"/tags/ssh/"}],"keywords":[{"name":"git","slug":"git","permalink":"/categories/git/"},{"name":"github","slug":"git/github","permalink":"/categories/git/github/"},{"name":"ssh","slug":"git/github/ssh","permalink":"/categories/git/github/ssh/"}]},{"title":"vue-element-table-滚动加载","slug":"vue-element-table_rolling-load/index","date":"2020-04-07T08:42:45.000Z","updated":"2022-11-21T06:46:45.879Z","comments":true,"path":"2020/04/07/vue-element-table_rolling-load/index/","link":"","permalink":"/2020/04/07/vue-element-table_rolling-load/index/","excerpt":"","text":"首先在main.js文件注册全局事件，代码如下： Vue.directive(&#39;loadmore&#39;, { bind(el, binding) { var p = 0; var t = 0; var down = true; var selectWrap = el.querySelector(&#39;.el-table__body-wrapper&#39;) selectWrap.addEventListener(&#39;scroll&#39;, function() { //判断是否向下滚动 p = this.scrollTop; // if ( t &lt; p){down=true}else{down=false} if(t &lt; p){ down = true; }else{ down = false; } t = p; //判断是否到底 const sign = 10; const scrollDistance = this.scrollHeight - this.scrollTop - this.clientHeight if (scrollDistance &lt;= sign &amp;&amp; down) { binding.value() } }) } }) 在组件中，使用自定义的事件：v-loadmore=”loadMore”在methods中调用loadMore这样就实现啦！！！","categories":[{"name":"VUE","slug":"VUE","permalink":"/categories/VUE/"},{"name":"element","slug":"VUE/element","permalink":"/categories/VUE/element/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"/tags/VUE/"},{"name":"element","slug":"element","permalink":"/tags/element/"},{"name":"table","slug":"table","permalink":"/tags/table/"},{"name":"滚动加载","slug":"滚动加载","permalink":"/tags/滚动加载/"}],"keywords":[{"name":"VUE","slug":"VUE","permalink":"/categories/VUE/"},{"name":"element","slug":"VUE/element","permalink":"/categories/VUE/element/"}]},{"title":"sortable+element实现表格行拖拽","slug":"sortable-element-drag/index","date":"2020-04-07T08:42:45.000Z","updated":"2022-11-21T06:45:23.696Z","comments":true,"path":"2020/04/07/sortable-element-drag/index/","link":"","permalink":"/2020/04/07/sortable-element-drag/index/","excerpt":"","text":"安装npm install vuedraggable 引入import Sortable from &#39;sortablejs&#39; el-table 添加row-key属性&lt;el-table ref=&quot;filterTable&quot; row-key=&quot;ip&quot; @filter-change=&quot;handlerFilterChange&quot; class=&quot;cl-table&quot; :data=&quot;resourceList&quot; v-loading=&quot;resourceListLoading&quot; stripe style=&quot;width:100%;&quot;&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;主机名&quot; :min-width=&quot;150&quot; show-overflow-tooltip&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; 将拖拽元素设置为要拖动项的父级元素mounted() { // 表格中需要实现行拖动，所以选中tr的父级元素 const table = document.querySelector(&#39;.el-table__body-wrapper tbody&#39;) const self = this Sortable.create(table, { onEnd({ newIndex, oldIndex }) { console.log(newIndex, oldIndex) const targetRow = self.resourceList.splice(oldIndex, 1)[0] self.resourceList.splice(newIndex, 0, targetRow) } }) }","categories":[{"name":"VUE","slug":"VUE","permalink":"/categories/VUE/"},{"name":"element","slug":"VUE/element","permalink":"/categories/VUE/element/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"/tags/VUE/"},{"name":"element","slug":"element","permalink":"/tags/element/"},{"name":"table","slug":"table","permalink":"/tags/table/"},{"name":"拖拽","slug":"拖拽","permalink":"/tags/拖拽/"}],"keywords":[{"name":"VUE","slug":"VUE","permalink":"/categories/VUE/"},{"name":"element","slug":"VUE/element","permalink":"/categories/VUE/element/"}]},{"title":"viewPort适配移动端","slug":"viewPort/index","date":"2020-04-07T08:42:17.000Z","updated":"2022-11-21T06:46:05.712Z","comments":true,"path":"2020/04/07/viewPort/index/","link":"","permalink":"/2020/04/07/viewPort/index/","excerpt":"","text":"PostCSS 基本插件默认安装vue-cli 脚手架 module.exports = { &quot;plugins&quot;: { &quot;postcss-import&quot;: {}, &quot;postcss-url&quot;: {}, // to edit target browsers: use &quot;browserslist&quot; field in package.json &quot;autoprefixer&quot;: {} } } PostCSS 其他插件安装其他插件 npm i postcss-aspect-ratio-mini postcss-px-to-viewport postcss-write-svg postcss-cssnext postcss-viewport-units cssnano --S 安装成功之后 package.json 显示： &quot;dependencies&quot;: { &quot;axios&quot;: &quot;^0.18.0&quot;, &quot;cssnano&quot;: &quot;^4.1.0&quot;, &quot;postcss-aspect-ratio-mini&quot;: &quot;0.0.2&quot;, &quot;postcss-cssnext&quot;: &quot;^3.1.0&quot;, &quot;postcss-px-to-viewport&quot;: &quot;0.0.3&quot;, &quot;postcss-viewport-units&quot;: &quot;^0.1.4&quot;, &quot;postcss-write-svg&quot;: &quot;^3.0.1&quot;, &quot;vue&quot;: &quot;^2.5.2&quot;, &quot;vue-router&quot;: &quot;^3.0.1&quot;, &quot;vuex&quot;: &quot;^3.0.1&quot; } .postcssrc.js 文件设置脚手架原有的三个配置项需要注释 autoprefixer ，理由是 cssnano 中已经具有此配置 module.exports = { &quot;plugins&quot;: { &quot;postcss-import&quot;: {}, &quot;postcss-url&quot;: {}, // to edit target browsers: use &quot;browserslist&quot; field in package.json // &quot;autoprefixer&quot;: {}, &quot;postcss-aspect-ratio-mini&quot;: {}, &quot;postcss-write-svg&quot;: { utf8: false }, &quot;postcss-cssnext&quot;: {}, &quot;postcss-px-to-viewport&quot;: { viewportWidth: 750, // 视窗的宽度，对应的是我们设计稿的宽度，一般是750 // viewportHeight: 1334, // 视窗的高度，根据750设备的宽度来指定，一般指定1334，也可以不设置 unitPrecision: 3, // 指定`px`转换为视窗单位值的小数位数（很多时候无法整除） viewportUnit: &#39;vw&#39;, // 指定需要转换成的视窗单位，建议使用vw selectorBlackList: [&#39;.ignore&#39;, &#39;.hairlines&#39;], // 指定不转换为视窗单位的类，可以自定义， 可以无限添加,建议定义一至两个通用的类名 minPixelValue: 1, // 小于或等于`1px`不转换为视窗单位，你也可以设置为你想要的值 mediaQuery: false // 允许在媒体查询中转换`px` }, &quot;postcss-viewport-units&quot;: {}, &quot;cssnano&quot;: { preset: &quot;advanced&quot;, autoprefixer: false, &quot;postcss-zindex&quot;: false } } } cssnano 插件安装在配置中我们使用了 preset: “advanced” ，所以还需要安装 npm i cssnano-preset-advanced --save-dev 基本配置 &quot;cssnano&quot;: { preset: &quot;advanced&quot;, autoprefixer: false, &quot;postcss-zindex&quot;: false } postcss-px-to-viewport这是核心的插件，帮助我们将 px 转成 vw、vh、vmin、vmax目前出视觉设计稿，都是使用 750px，那么 100vw = 750px，即 1vw = 7.5px。那么我们根据设计图上 的px 值直接转换成对于的 vw 值。实际撸码过程中，不需要做任何计算，直接在代码中写 px 即可","categories":[{"name":"VUE","slug":"VUE","permalink":"/categories/VUE/"},{"name":"移动端","slug":"VUE/移动端","permalink":"/categories/VUE/移动端/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"/tags/VUE/"},{"name":"移动端","slug":"移动端","permalink":"/tags/移动端/"}],"keywords":[{"name":"VUE","slug":"VUE","permalink":"/categories/VUE/"},{"name":"移动端","slug":"VUE/移动端","permalink":"/categories/VUE/移动端/"}]}]}